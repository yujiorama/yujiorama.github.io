<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.10">
<meta name="description" content="index page of ArchUnit's documentation">
<meta name="keywords" content="ArchUnit, Java, architecture, test, analysis">
<title>ArchUnit User Guide</title>
<style>
/* Adapted for ArchUnit */
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#0563a5;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#000;font-weight:400;margin-top:0;margin-bottom:.25em}
#toctitle{color:#000;font-size:1.2em}

/* Asciidoctor default stylesheet | MIT License | http://asciidoctor.org */
/* Remove comment around @import statement below when using as a custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section,summary{display:block}
audio,canvas,video{display:inline-block}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
script{display:none!important}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:transparent}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="search"]{-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*:before,*:after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.spread{width:100%}
p.lead,.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{font-size:1.21875em;line-height:1.6}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:none}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #ddddd8;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite:before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media only screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7;font-weight:bold}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt,table tr:nth-of-type(even){background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix:before,.clearfix:after,.float-group:before,.float-group:after{content:" ";display:table}
.clearfix:after,.float-group:after{clear:both}
*:not(pre)>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background-color:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
*:not(pre)>code.nobreak{word-wrap:normal}
*:not(pre)>code.nowrap{white-space:nowrap}
pre,pre>code{line-height:1.45;color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;text-rendering:optimizeSpeed}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background-color:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button:before,b.button:after{position:relative;top:-1px;font-weight:400}
b.button:before{content:"[";padding:0 3px 0 2px}
b.button:after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header:before,#header:after,#content:before,#content:after,#footnotes:before,#footnotes:after,#footer:before,#footer:after{content:" ";display:table}
#header:after,#content:after,#footnotes:after,#footer:after{clear:both}
#content{margin-top:1.25em}
#content:before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #ddddd8}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #ddddd8;padding-bottom:8px}
#header .details{border-bottom:1px solid #ddddd8;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span:before{content:"\00a0\2013\00a0"}
#header .details br+span.author:before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark:before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber:after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #ddddd8;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #efefed;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
@media only screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background-color:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #efefed;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #efefed;left:auto;right:0}}
@media only screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background-color:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media only screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #efefed}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor:before,h2>a.anchor:before,h3>a.anchor:before,#toctitle>a.anchor:before,.sidebarblock>.content>.title>a.anchor:before,h4>a.anchor:before,h5>a.anchor:before,h6>a.anchor:before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock>caption.title{white-space:nowrap;overflow:visible;max-width:0}
.paragraph.lead>p,#preamble>.sectionbody>.paragraph:first-of-type p{color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>.paragraph:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #ddddd8;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock pre:not(.highlight),.listingblock pre[class="highlight"],.listingblock pre[class^="highlight "],.listingblock pre.CodeRay,.listingblock pre.prettyprint{background:#f7f7f8}
.sidebarblock .literalblock pre,.sidebarblock .listingblock pre:not(.highlight),.sidebarblock .listingblock pre[class="highlight"],.sidebarblock .listingblock pre[class^="highlight "],.sidebarblock .listingblock pre.CodeRay,.sidebarblock .listingblock pre.prettyprint{background:#f2f1f1}
.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;padding:1em;font-size:.8125em}
.literalblock pre.nowrap,.literalblock pre[class].nowrap,.listingblock pre.nowrap,.listingblock pre[class].nowrap{overflow-x:auto;white-space:pre;word-wrap:normal}
@media only screen and (min-width:768px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:.90625em}}
@media only screen and (min-width:1280px){.literalblock pre,.literalblock pre[class],.listingblock pre,.listingblock pre[class]{font-size:1em}}
.literalblock.output pre{color:#f7f7f8;background-color:rgba(0,0,0,.9)}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.listingblock>.content{position:relative}
.listingblock code[data-lang]:before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:#999}
.listingblock:hover code[data-lang]:before{display:block}
.listingblock.terminal pre .command:before{content:attr(data-prompt);padding-right:.5em;color:#999}
.listingblock.terminal pre .command:not([data-prompt]):before{content:"$"}
table.pyhltable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.pyhltable td{vertical-align:top;padding-top:0;padding-bottom:0;line-height:1.45}
table.pyhltable td.code{padding-left:.75em;padding-right:0}
pre.pygments .lineno,table.pyhltable td:not(.code){color:#999;padding-left:0;padding-right:.5em;border-right:1px solid #ddddd8}
pre.pygments .lineno{display:inline-block;margin-right:.25em}
table.pyhltable .linenodiv{background:none!important;padding-right:0!important}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock blockquote p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote:before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.5em;margin-right:.5ex;text-align:right}
.quoteblock .quoteblock{margin-left:0;margin-right:0;padding:.5em 0;border-left:3px solid rgba(0,0,0,.6)}
.quoteblock .quoteblock blockquote{padding:0 0 0 .75em}
.quoteblock .quoteblock blockquote:before{display:none}
.verseblock{margin:0 1em 1.25em 1em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract{margin:0 0 1.25em 0;display:block}
.quoteblock.abstract blockquote,.quoteblock.abstract blockquote p{text-align:left;word-spacing:0}
.quoteblock.abstract blockquote:before,.quoteblock.abstract blockquote p:first-of-type:before{display:none}
table.tableblock{max-width:100%;border-collapse:separate}
table.tableblock td>.paragraph:last-child p>p:last-child,table.tableblock th>p:last-child,table.tableblock td>p:last-child{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px 0}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot{border-width:1px 0}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
td>div.verse{white-space:pre}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0 .75em;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left,.imageblock[style*="float: left"]{margin:.25em .625em 1.25em 0}
.imageblock.right,.imageblock[style*="float: right"]{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em 0;border-width:1px 0 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background-color:#00fafa}
.black{color:#000}
.black-background{background-color:#000}
.blue{color:#0000bf}
.blue-background{background-color:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background-color:#fa00fa}
.gray{color:#606060}
.gray-background{background-color:#7d7d7d}
.green{color:#006000}
.green-background{background-color:#007d00}
.lime{color:#00bf00}
.lime-background{background-color:#00fa00}
.maroon{color:#600000}
.maroon-background{background-color:#7d0000}
.navy{color:#000060}
.navy-background{background-color:#00007d}
.olive{color:#606000}
.olive-background{background-color:#7d7d00}
.purple{color:#600060}
.purple-background{background-color:#7d007d}
.red{color:#bf0000}
.red-background{background-color:#fa0000}
.silver{color:#909090}
.silver-background{background-color:#bcbcbc}
.teal{color:#006060}
.teal-background{background-color:#007d7d}
.white{color:#bfbfbf}
.white-background{background-color:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background-color:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background-color:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]:after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background-color:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@media print{@page{margin:1.25cm .75cm}
*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare):after,a[href^="https:"]:not(.bare):after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]:after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #ddddd8!important;padding-bottom:0!important}
.sect1{padding-bottom:0!important}
.sect1+.sect1{border:0!important}
#header>h1:first-child{margin-top:1.25rem}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em 0}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span:before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]:before{display:block}
#footer{background:none!important;padding:0 .9375em}
#footer-text{color:rgba(0,0,0,.6)!important;font-size:.9em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}

/* Some custom overrides to force some styles*/
h2 {
    margin-top: 1.5em !important;
    margin-bottom: 0.75em !important;
}
h3 {
    margin-top: 1.3em !important;
    margin-bottom: 0.65em !important;
}
h4 {
    margin-top: 1.2em !important;
    margin-bottom: 0.55em !important;
}
</style>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body class="article toc2 toc-left">
<div id="header">
<h1>ArchUnit User Guide</h1>
<div class="details">
<span id="revnumber">version v0.21.0</span>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="#_前書きintroduction">1. 前書き（Introduction）</a>
<ul class="sectlevel2">
<li><a href="#_モジュールの概要module_overview">1.1. モジュールの概要（Module Overview）</a></li>
</ul>
</li>
<li><a href="#_インストールinstallation">2. インストール（Installation）</a>
<ul class="sectlevel2">
<li><a href="#_junit_4">2.1. JUnit 4</a></li>
<li><a href="#_junit_5">2.2. JUnit 5</a></li>
<li><a href="#_その他のテストフレームワークについてother_test_frameworks">2.3. その他のテストフレームワークについて（Other Test Frameworks）</a></li>
<li><a href="#_maven_プラグインmaven_plugin">2.4. Maven プラグイン（Maven Plugin）</a></li>
</ul>
</li>
<li><a href="#_archunit_入門getting_started">3. ArchUnit 入門（Getting Started）</a>
<ul class="sectlevel2">
<li><a href="#_クラスのインポートimporting_classes">3.1. クラスのインポート（Importing Classes）</a></li>
<li><a href="#_アーキテクチャにおける制約のアサーションasserting_architectural_constraints">3.2. （アーキテクチャにおける）制約のアサーション（Asserting (Architectural) Constraints）</a></li>
<li><a href="#_junit_4_と_junit_5_のどちらかを使いましょうusing_junit_4_or_junit_5">3.3. JUnit 4 と JUnit 5 のどちらかを使いましょう（Using JUnit 4 or JUnit 5）</a></li>
<li><a href="#_kotlin_で_junit_を使うusing_junit_support_with_kotlin">3.4. Kotlin で JUnit を使う（Using JUnit support with Kotlin）</a></li>
</ul>
</li>
<li><a href="#_チェックの対象what_to_check">4. チェックの対象（What to Check）</a>
<ul class="sectlevel2">
<li><a href="#_パッケージの依存性チェックpackage_dependency_checks">4.1. パッケージの依存性チェック（Package Dependency Checks）</a></li>
<li><a href="#_クラスの依存性チェックclass_dependency_checks">4.2. クラスの依存性チェック（Class Dependency Checks）</a></li>
<li><a href="#_クラスおよびパッケージの閉じ込め状況チェックclass_and_package_containment_checks">4.3. クラスおよびパッケージの閉じ込め状況チェック（Class and Package Containment Checks）</a></li>
<li><a href="#_継承関係のチェックinheritance_checks">4.4. 継承関係のチェック（Inheritance Checks）</a></li>
<li><a href="#_アノテーションのチェックannotation_checks">4.5. アノテーションのチェック（Annotation Checks）</a></li>
<li><a href="#_レイヤーのチェックlayer_checks">4.6. レイヤーのチェック（Layer Checks）</a></li>
<li><a href="#_循環のチェックcycle_checks">4.7. 循環のチェック（Cycle Checks）</a></li>
</ul>
</li>
<li><a href="#_考え方と概念ideas_and_concepts">5. 考え方と概念（Ideas and Concepts）</a>
<ul class="sectlevel2">
<li><a href="#_コアレイヤーcore">5.1. コアレイヤー（Core）</a></li>
<li><a href="#_言語レイヤーlang">5.2. 言語レイヤー（Lang）</a></li>
<li><a href="#_ライブラリレイヤーlibrary">5.3. ライブラリレイヤー（Library）</a></li>
</ul>
</li>
<li><a href="#_コア_apithe_core_api">6. コア API（The Core API）</a>
<ul class="sectlevel2">
<li><a href="#_インポートimport">6.1. インポート（Import）</a></li>
<li><a href="#_ドメインdomain">6.2. ドメイン（Domain）</a></li>
</ul>
</li>
<li><a href="#_言語_apithe_lang_api">7. 言語 API（The Lang API）</a>
<ul class="sectlevel2">
<li><a href="#_クラスルールの合成composing_class_rules">7.1. クラスルールの合成（Composing Class Rules）</a></li>
<li><a href="#_メンバールールの合成composing_member_rules">7.2. メンバールールの合成（Composing Member Rules）</a></li>
<li><a href="#_独自ルールの作成creating_custom_rules">7.3. 独自ルールの作成（Creating Custom Rules）</a></li>
<li><a href="#_定義済みの述語式と条件式predefined_predicates_and_conditions">7.4. 定義済みの述語式と条件式（Predefined Predicates and Conditions）</a></li>
<li><a href="#_独自の考え方に基づくルールrules_with_custom_concepts">7.5. 独自の考え方に基づくルール（Rules with Custom Concepts）</a></li>
<li><a href="#_ルールの文章を制御するcontrolling_the_rule_text">7.6. ルールの文章を制御する（Controlling the Rule Text）</a></li>
<li><a href="#_違反を無視するignoring_violations">7.7. 違反を無視する（Ignoring Violations）</a></li>
</ul>
</li>
<li><a href="#_ライブラリ_apithe_library_api">8. ライブラリ API（The Library API）</a>
<ul class="sectlevel2">
<li><a href="#_アーキテクチャarchitectures">8.1. アーキテクチャ（Architectures）</a></li>
<li><a href="#_ソースコードの断面slices">8.2. ソースコードの断面（Slices）</a></li>
<li><a href="#_一般的なコーディングルールgeneral_coding_rules">8.3. 一般的なコーディングルール（General Coding Rules）</a></li>
<li><a href="#_plantuml_のコンポーネント図をルールとして扱うplantuml_component_diagrams_as_rules">8.4. PlantUML のコンポーネント図をルールとして扱う（PlantUML Component Diagrams as rules）</a></li>
<li><a href="#_アーキテクチャルール違反の永続化freezing_arch_rules">8.5. アーキテクチャルール違反の永続化（Freezing Arch Rules）</a></li>
<li><a href="#_ソフトウェアアーキテクチャのメトリクスsoftware_architecture_metrics">8.6. ソフトウェアアーキテクチャのメトリクス（Software Architecture Metrics）</a></li>
</ul>
</li>
<li><a href="#_junit_拡張機能junit_support">9. JUnit 拡張機能（JUnit Support）</a>
<ul class="sectlevel2">
<li><a href="#_junit_4_および_junit_5_への対応junit_4_5_support">9.1. JUnit 4 および JUnit 5 への対応（JUnit 4 &amp; 5 Support）</a></li>
</ul>
</li>
<li><a href="#_高度な設定advanced_configuration">10. 高度な設定（Advanced Configuration）</a>
<ul class="sectlevel2">
<li><a href="#_設定の上書きoverriding_configuration">10.1. 設定の上書き（Overriding configuration）</a></li>
<li><a href="#_解決のための振る舞いの構成configuring_the_resolution_behavior">10.2. 解決のための振る舞いの構成（Configuring the Resolution Behavior）</a></li>
<li><a href="#_クラスの_md5_チェックサムmd5_sums_of_classes">10.3. クラスの MD5 チェックサム（MD5 Sums of Classes）</a></li>
<li><a href="#_エラーメッセージのカスタマイズcustom_error_messages">10.4. エラーメッセージのカスタマイズ（Custom Error Messages）</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_前書きintroduction"><a class="anchor" href="#_前書きintroduction"></a>1. 前書き（Introduction）</h2>
<div class="sectionbody">
<div class="paragraph">
<p><a href="https://archunit.org">ArchUnit</a> is a free, simple and extensible library for checking the
architecture of your Java code.
That is, ArchUnit can check dependencies between packages and classes, layers and slices,
check for cyclic dependencies and more. It does so by analyzing given Java bytecode,
importing all classes into a Java code structure.
ArchUnit&#8217;s main focus is to automatically test architecture and coding rules,
using any plain Java unit testing framework.</p>
</div>
<div class="paragraph">
<p><a href="https://archunit.org">ArchUnit</a>はJavaソースコードのアーキテクチャをチェックする、簡潔性と拡張性に優れたフリーなライブラリです。
ArchUnitはパッケージやクラス間の依存関係に加えて、レイヤーやスライス間の依存関係をチェックできます。それ以外に、循環する依存関係もチェックできます。
依存関係のチェックは、Javaソースコードに登場する全てのクラスをインポートしたバイトコードについて行います。
ArchUnitの主な目的は、一般的なユニットテストフレームワークで、アーキテクチャやコーディングルールを自動的にテストすることです。</p>
</div>
<div class="sect2">
<h3 id="_モジュールの概要module_overview"><a class="anchor" href="#_モジュールの概要module_overview"></a>1.1. モジュールの概要（Module Overview）</h3>
<div class="paragraph">
<p>ArchUnit consists of the following production modules: <code>archunit</code>, <code>archunit-junit4</code> as well
as <code>archunit-junit5-api</code>, <code>archunit-junit5-engine</code> and <code>archunit-junit5-engine-api</code>.
Also relevant for end users is the <code>archunit-example</code> module.</p>
</div>
<div class="paragraph">
<p>ArchUnitの公開モジュールは <code>archunit</code> と、<code>archunit-junit4</code> あるいは <code>archunit-junit5-api</code>、<code>archunit-junit5-engine</code>、<code>archunit-junit5-engine-api</code> です。
エンドユーザとしては <code>archunit-example</code> モジュールも参考になるでしょう。</p>
</div>
<div class="sect3">
<h4 id="_archunit_モジュールmodule_archunit"><a class="anchor" href="#_archunit_モジュールmodule_archunit"></a>1.1.1. archunit モジュール（Module archunit）</h4>
<div class="paragraph">
<p>This module contains the actual ArchUnit core infrastructure required to write architecture
tests: The <code>ClassFileImporter</code>,
the domain objects, as well as the rule syntax infrastructure.</p>
</div>
<div class="paragraph">
<p>このモジュールはアーキテクチャテストを記述するために必要な ArchUnit の基本部品を含んでいます。
例えば <code>ClassFileImporter</code> というドメインオブジェクトや、ルールの文法を定義する部品を含んでいます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_archunit_junit4_モジュールmodule_archunit_junit4"><a class="anchor" href="#_archunit_junit4_モジュールmodule_archunit_junit4"></a>1.1.2. archunit-junit4 モジュール（Module archunit-junit4）</h4>
<div class="paragraph">
<p>This module contains the infrastructure to integrate with JUnit 4, in particular
the <code>ArchUnitRunner</code> to cache imported classes.</p>
</div>
<div class="paragraph">
<p>このモジュールは ArchUnit を JUnit 4 へ統合するための部品を含んでいます。
特に <code>ArchUnitRunner</code> はインポートしたクラス（のバイトコード）をキャッシュするようになっています。</p>
</div>
</div>
<div class="sect3">
<h4 id="_archunit_junit5_モジュールmodules_archunit_junit5"><a class="anchor" href="#_archunit_junit5_モジュールmodules_archunit_junit5"></a>1.1.3. archunit-junit5-* モジュール（Modules archunit-junit5-*）</h4>
<div class="paragraph">
<p>These modules contain the infrastructure to integrate with JUnit 5 and contain the respective
infrastructure to cache imported classes between test runs.
<code>archunit-junit5-api</code> contains the user API to write tests with ArchUnit&#8217;s JUnit 5 support,
<code>archunit-junit5-engine</code> contains the runtime engine to run those tests.
<code>archunit-junit5-engine-api</code> contains API code for tools that want more detailed control
over running ArchUnit JUnit 5 tests, in particular a <code>FieldSelector</code> which can be used to
instruct the <code>ArchUnitTestEngine</code> to run a specific rule field (compare <a href="#_junit_4_および_junit_5_への対応junit_4_5_support">JUnit 4 &amp; 5 Support</a>).</p>
</div>
<div class="paragraph">
<p>これらのモジュールは ArchUnit を JUnit 5 へ統合するための部品を含んでいます。
また、それぞれのテストケースについてインポートしたクラス（のバイトコード）をキャッシュするための部品も含んでいます。
<code>archunit-junit5-api</code> は JUnit 5 で ArchUnit のテストを記述するためのユーザ向けAPIを含んでいます。
<code>archunit-junit5-engine</code> はテストを実行するランタイムエンジンを含んでいます。
<code>archunit-junit5-engine-api</code> はテストツールがより適切に JUnit 5 の ArchUnit テストを制御するためのAPIコードを含んでいます。
例えば、<code>FieldSelector</code> は <code>ArchUnitTestEngine</code> に特定のルールフィールドだけを実行させることができます。
（ <a href="#_junit_4_および_junit_5_への対応junit_4_5_support">JUnit 4 &amp; 5 Support</a> とも読み比べてみてください）</p>
</div>
</div>
<div class="sect3">
<h4 id="_archunit_example_モジュールmodule_archunit_example"><a class="anchor" href="#_archunit_example_モジュールmodule_archunit_example"></a>1.1.4. archunit-example モジュール（Module archunit-example）</h4>
<div class="paragraph">
<p>This module contains example architecture rules and sample code that violates these rules.
Look here to get inspiration on how to set up rules for your project, or at
<a href="https://github.com/TNG/ArchUnit-Examples">ArchUnit-Examples</a> for the last released version.</p>
</div>
<div class="paragraph">
<p>このモジュールはアーキテクチャルールの具体例や、ルール違反しているサンプルコードを含んでいます。
このモジュールを見れば、あなたのプロジェクトで整備するルールについてひらめきを得ることができるでしょう。
最新バージョンは <a href="https://github.com/TNG/ArchUnit-Examples">ArchUnit-Examples</a> で参照できます。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_インストールinstallation"><a class="anchor" href="#_インストールinstallation"></a>2. インストール（Installation）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>To use ArchUnit, it is sufficient to include the respective JAR files in the classpath.
Most commonly, this is done by adding the dependency to your dependency management tool,
which is illustrated for Maven and Gradle below. Alternatively you
can obtain the necessary JAR files directly from
<a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.tngtech.archunit%22">Maven Central</a>.</p>
</div>
<div class="paragraph">
<p>ArchUnitを使うには、必要なJarファイルをクラスパスに配置します。
普通ならMavenやGradleなどの依存性管理ツールへ依存ライブラリを追加することになるでしょう。
<a href="http://search.maven.org/#search%7Cga%7C1%7Cg%3A%22com.tngtech.archunit%22">Maven Central</a>から必要なJarファイルを直接ダウンロードすることも可能です。</p>
</div>
<div class="sect2">
<h3 id="_junit_4"><a class="anchor" href="#_junit_4"></a>2.1. JUnit 4</h3>
<div class="paragraph">
<p>To use ArchUnit in combination with JUnit 4, include the following dependency from
Maven Central:</p>
</div>
<div class="paragraph">
<p>ArchUnit を JUnit 4 と組み合わせて使用するには、Maven Central から次のような依存ライブラリを追加します。</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="xml" class="language-xml hljs">&lt;dependency&gt;
    &lt;groupId&gt;com.tngtech.archunit&lt;/groupId&gt;
    &lt;artifactId&gt;archunit-junit4&lt;/artifactId&gt;
    &lt;version&gt;v0.21.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">dependencies {
    testImplementation 'com.tngtech.archunit:archunit-junit4:v0.21.0'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_junit_5"><a class="anchor" href="#_junit_5"></a>2.2. JUnit 5</h3>
<div class="paragraph">
<p>ArchUnit&#8217;s JUnit 5 artifacts follow the pattern of JUnit Jupiter. There is one artifact containing
the API, i.e. the compile time dependencies to write tests. Then there is another artifact containing
the actual <code>TestEngine</code> used at runtime. Just like JUnit Jupiter ArchUnit offers one convenience
artifact transitively including both API and engine with the correct scope, which in turn can be added
as a test compile dependency. Thus to include ArchUnit&#8217;s JUnit 5 support, simply add the following dependency
from Maven Central:</p>
</div>
<div class="paragraph">
<p>ArchUnit の JUnit 5 向けアーティファクトは、JUnit Jupiter と同じ構成になっています。
1つはテストを記述するためのAPIを含む、コンパイル依存関係のアーティファクトです。
もう1つは実際にテストを実行する <code>TestEngine</code> を含むアーティファクトです。
JUnit Jupiter のように、API とエンジン両方のアーティファクトへ適切なスコープで依存するアーティファクトがあるので、テストコンパイル依存関係として追加すれば推移的依存関係として解決されるので便利です。
ですから、ArchUnit を JUnit 5 と組み合わせて使用するには、Maven Central から次のような依存ライブラリを追加するだけです。</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="xml" class="language-xml hljs">&lt;dependency&gt;
    &lt;groupId&gt;com.tngtech.archunit&lt;/groupId&gt;
    &lt;artifactId&gt;archunit-junit5&lt;/artifactId&gt;
    &lt;version&gt;v0.21.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">dependencies {
    testImplementation 'com.tngtech.archunit:archunit-junit5:v0.21.0'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_その他のテストフレームワークについてother_test_frameworks"><a class="anchor" href="#_その他のテストフレームワークについてother_test_frameworks"></a>2.3. その他のテストフレームワークについて（Other Test Frameworks）</h3>
<div class="paragraph">
<p>ArchUnit works with any test framework that executes Java code. To use ArchUnit in such a
context, include the core ArchUnit dependency from Maven Central:</p>
</div>
<div class="paragraph">
<p>ArchUnit は Java に対応するあらゆるテストフレームワークから使用できます。
その場合、Maven Central から取得したコアモジュールを依存ライブラリとして追加します。</p>
</div>
<div class="listingblock">
<div class="title">pom.xml</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="xml" class="language-xml hljs">&lt;dependency&gt;
    &lt;groupId&gt;com.tngtech.archunit&lt;/groupId&gt;
    &lt;artifactId&gt;archunit&lt;/artifactId&gt;
    &lt;version&gt;v0.21.0&lt;/version&gt;
    &lt;scope&gt;test&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">build.gradle</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">dependencies {
   testImplementation 'com.tngtech.archunit:archunit:v0.21.0'
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_maven_プラグインmaven_plugin"><a class="anchor" href="#_maven_プラグインmaven_plugin"></a>2.4. Maven プラグイン（Maven Plugin）</h3>
<div class="paragraph">
<p>There exists a Maven plugin by Société Générale to run ArchUnit rules straight from Maven. For
more information visit their GitHub repo: <a href="https://github.com/societe-generale/arch-unit-maven-plugin" class="bare">https://github.com/societe-generale/arch-unit-maven-plugin</a></p>
</div>
<div class="paragraph">
<p>Société Générale さんが Maven から直接 ArchUnit を実行できるプラグインを公開してくれています。
詳しくは GitHub のリポジトリ <a href="https://github.com/societe-generale/arch-unit-maven-plugin" class="bare">https://github.com/societe-generale/arch-unit-maven-plugin</a> を参照してください。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_archunit_入門getting_started"><a class="anchor" href="#_archunit_入門getting_started"></a>3. ArchUnit 入門（Getting Started）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ArchUnit tests are written the same way as any Java unit test and can be written with any
Java unit testing framework. To really understand the ideas behind ArchUnit, one should consult
<a href="#_考え方と概念ideas_and_concepts">Ideas and Concepts</a>. The following will outline a "technical" getting started.</p>
</div>
<div class="paragraph">
<p>ArchUnit のテストはユニットテストと同じやり方で、そしてあらゆるユニットテストフレームワークを使用して記述できます。
ArchUnit の背景となる考え方を正確に理解したければ、<a href="#_考え方と概念ideas_and_concepts">Ideas and Concepts</a>を読んでみてください。
以降の説明は「技術的な」入門です。</p>
</div>
<div class="sect2">
<h3 id="_クラスのインポートimporting_classes"><a class="anchor" href="#_クラスのインポートimporting_classes"></a>3.1. クラスのインポート（Importing Classes）</h3>
<div class="paragraph">
<p>At its core ArchUnit provides infrastructure to import Java bytecode into Java code structures.
This can be done using the <code>ClassFileImporter</code></p>
</div>
<div class="paragraph">
<p>ArchUnitの基本部品は、Javaバイトコードをソースコード構造へインポートする <code>ClassFileImporter</code> です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaClasses classes = new ClassFileImporter().importPackages("com.mycompany.myapp");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ClassFileImporter</code> offers many ways to import classes. Some ways depend on
the current project&#8217;s classpath, like <code>importPackages(..)</code>. However there are other ways
that do not, for example:</p>
</div>
<div class="paragraph">
<p><code>ClassFileImpoter</code> はクラスをインポートするためのさまざまな方法を提供します。
<code>importPackages(..)</code> のようにプロジェクトのクラスパスへ依存する方法もありますが、次のようにそうでない方法もあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaClasses classes = new ClassFileImporter().importPath("/some/path");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The returned object of type <code>JavaClasses</code> represents a collection of elements of type
<code>JavaClass</code>, where <code>JavaClass</code> in turn represents a single imported class file. You can
in fact access most properties of the imported class via the public API:</p>
</div>
<div class="paragraph">
<p>返り値の <code>JavaClasses</code> 型のオブジェクトは、<code>JavaClass</code> 型のオブジェクトの集合です。
<code>JavaClass</code> はインポートしたいずれかのクラスファイルに対応しています。
public APIにより、インポートしたクラスのほとんどのプロパティを参照できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaClass clazz = classes.get(Object.class);
System.out.print(clazz.getSimpleName()); // returns 'Object'</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_アーキテクチャにおける制約のアサーションasserting_architectural_constraints"><a class="anchor" href="#_アーキテクチャにおける制約のアサーションasserting_architectural_constraints"></a>3.2. （アーキテクチャにおける）制約のアサーション（Asserting (Architectural) Constraints）</h3>
<div class="paragraph">
<p>To express architectural rules, like 'Services should only be accessed by Controllers',
ArchUnit offers an abstract DSL-like fluent API, which can in turn be evaluated against
imported classes. To specify a rule, use the class <code>ArchRuleDefinition</code> as entry point:</p>
</div>
<div class="paragraph">
<p>例えば「サービスにアクセスできるのはコントローラーだけでなければならない」というアーキテクチャルールを ArchUnit で表現するには、フルーエントAPIを抽象的なDSLとして、インポートしたクラスを評価できます。
実際にルールを定義するときは、<code>ArchRuleDefinition</code> クラスを起点にします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">import static com.tngtech.archunit.lang.syntax.ArchRuleDefinition.classes;

// ...

ArchRule myRule = classes()
    .that().resideInAPackage("..service..")
    .should().onlyBeAccessed().byAnyPackage("..controller..", "..service..");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The two dots represent any number of packages (compare AspectJ Pointcuts). The returned
object of type <code>ArchRule</code> can now be evaluated against a set of imported classes:</p>
</div>
<div class="paragraph">
<p>パッケージ名を指定する文字列に含まれる連続する2つのドットは、任意の数のパッケージ階層を表しています（AspectJ のポイントカットを記述する場合と同様です）。
返り値の <code>ArchRule</code> 型のオブジェクトを使うと、インポートしたクラスの集合を評価できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">myRule.check(importedClasses);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus the complete example could look like</p>
</div>
<div class="paragraph">
<p>全てを組み合わせた完全な具体例は次のとおりです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@Test
public void Services_should_only_be_accessed_by_Controllers() {
    JavaClasses importedClasses = new ClassFileImporter().importPackages("com.mycompany.myapp");

    ArchRule myRule = classes()
        .that().resideInAPackage("..service..")
        .should().onlyBeAccessed().byAnyPackage("..controller..", "..service..");

    myRule.check(importedClasses);
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_junit_4_と_junit_5_のどちらかを使いましょうusing_junit_4_or_junit_5"><a class="anchor" href="#_junit_4_と_junit_5_のどちらかを使いましょうusing_junit_4_or_junit_5"></a>3.3. JUnit 4 と JUnit 5 のどちらかを使いましょう（Using JUnit 4 or JUnit 5）</h3>
<div class="paragraph">
<p>While ArchUnit can be used with any unit testing framework, it provides extended support
for writing tests with JUnit 4 and JUnit 5. The main advantage is automatic caching of imported
classes between tests (of the same imported classes), as well as reduction of boilerplate code.</p>
</div>
<div class="paragraph">
<p>ArchUnit はどのようなユニットテストフレームワークでも使用できますが、JUnit4 あるいは JUnit 5 を使ってテストを書くための拡張機能が備わっています。
主な利点はインポートしたクラスのキャッシュをテストケース間で再利用できることです。
そうすると、ボイラープレートコードの記述を減らすことができます。</p>
</div>
<div class="paragraph">
<p>To use the JUnit support, declare ArchUnit&#8217;s <code>ArchUnitRunner</code> (only JUnit 4), declare the classes
to import via <code>@AnalyzeClasses</code> and add the respective rules as fields:</p>
</div>
<div class="paragraph">
<p>JUnit 用の拡張機能を使うには、<code>ArchUnitRunner</code> を宣言し（JUnit 4 の場合のみ）、インポートするクラスを <code>@AnalyzeClasses</code> で指定します。
そして、ルールをテストクラスのフィールドとして定義します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@RunWith(ArchUnitRunner.class) // Remove this line for JUnit 5!!
@AnalyzeClasses(packages = "com.mycompany.myapp")
public class MyArchitectureTest {

    @ArchTest
    public static final ArchRule myRule = classes()
        .that().resideInAPackage("..service..")
        .should().onlyBeAccessed().byAnyPackage("..controller..", "..service..");

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The JUnit test support will automatically import (or reuse) the specified classes and
evaluate any rule annotated with <code>@ArchTest</code> against those classes.</p>
</div>
<div class="paragraph">
<p>JUnit 用の拡張機能は、指定したクラスを自動的にインポートし、再利用するようになります。
また、<code>@ArchTest</code> で修飾されたあらゆるルールを評価するようになります。</p>
</div>
<div class="paragraph">
<p>For further information on how to use the JUnit support refer to <a href="#_junit_拡張機能junit_support">JUnit Support</a>.</p>
</div>
<div class="paragraph">
<p>より詳しい使い方は <a href="#_junit_拡張機能junit_support">JUnit Support</a> を参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="_kotlin_で_junit_を使うusing_junit_support_with_kotlin"><a class="anchor" href="#_kotlin_で_junit_を使うusing_junit_support_with_kotlin"></a>3.4. Kotlin で JUnit を使う（Using JUnit support with Kotlin）</h3>
<div class="paragraph">
<p>Using the JUnit support with Kotlin is quite similar to Java:</p>
</div>
<div class="paragraph">
<p>JUnit 用の拡張機能を Kotlin から使う方法は Java の場合とほとんど変わりません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="kotlin" class="language-kotlin hljs">@RunWith(ArchUnitRunner::class) // Remove this line for JUnit 5!!
@AnalyzeClasses(packagesOf = [MyArchitectureTest::class])
class MyArchitectureTest {
    @ArchTest
    val rule_as_field = ArchRuleDefinition.noClasses().should()...

    @ArchTest
    fun rule_as_method(importedClasses: JavaClasses) {
        val rule = ArchRuleDefinition.noClasses().should()...
        rule.check(importedClasses)
    }
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_チェックの対象what_to_check"><a class="anchor" href="#_チェックの対象what_to_check"></a>4. チェックの対象（What to Check）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The following section illustrates some typical checks you could do with ArchUnit.</p>
</div>
<div class="paragraph">
<p>このセクションでは、ArchUnit の典型的なチェック内容を説明します。</p>
</div>
<div class="sect2">
<h3 id="_パッケージの依存性チェックpackage_dependency_checks"><a class="anchor" href="#_パッケージの依存性チェックpackage_dependency_checks"></a>4.1. パッケージの依存性チェック（Package Dependency Checks）</h3>
<div class="imageblock">
<div class="content">
<img src="package-deps-no-access.png" alt="package deps no access" width="441" height="80">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">noClasses().that().resideInAPackage("..source..")
    .should().dependOnClassesThat().resideInAPackage("..foo..")</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="package-deps-only-access.png" alt="package deps only access" width="463" height="339">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">classes().that().resideInAPackage("..foo..")
    .should().onlyHaveDependentClassesThat().resideInAnyPackage("..source.one..", "..foo..")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_クラスの依存性チェックclass_dependency_checks"><a class="anchor" href="#_クラスの依存性チェックclass_dependency_checks"></a>4.2. クラスの依存性チェック（Class Dependency Checks）</h3>
<div class="imageblock">
<div class="content">
<img src="class-naming-deps.png" alt="class naming deps" width="302" height="216">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">classes().that().haveNameMatching(".*Bar")
    .should().onlyHaveDependentClassesThat().haveSimpleName("Bar")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_クラスおよびパッケージの閉じ込め状況チェックclass_and_package_containment_checks"><a class="anchor" href="#_クラスおよびパッケージの閉じ込め状況チェックclass_and_package_containment_checks"></a>4.3. クラスおよびパッケージの閉じ込め状況チェック（Class and Package Containment Checks）</h3>
<div class="imageblock">
<div class="content">
<img src="class-package-contain.png" alt="class package contain" width="326" height="182">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">classes().that().haveSimpleNameStartingWith("Foo")
    .should().resideInAPackage("com.foo")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_継承関係のチェックinheritance_checks"><a class="anchor" href="#_継承関係のチェックinheritance_checks"></a>4.4. 継承関係のチェック（Inheritance Checks）</h3>
<div class="imageblock">
<div class="content">
<img src="inheritance-naming-check.png" alt="inheritance naming check" width="432" height="232">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">classes().that().implement(Connection.class)
    .should().haveSimpleNameEndingWith("Connection")</code></pre>
</div>
</div>
<div class="imageblock">
<div class="content">
<img src="inheritance-access-check.png" alt="inheritance access check" width="516" height="253">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">classes().that().areAssignableTo(EntityManager.class)
    .should().onlyHaveDependentClassesThat().resideInAnyPackage("..persistence..")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_アノテーションのチェックannotation_checks"><a class="anchor" href="#_アノテーションのチェックannotation_checks"></a>4.5. アノテーションのチェック（Annotation Checks）</h3>
<div class="imageblock">
<div class="content">
<img src="inheritance-annotation-check.png" alt="inheritance annotation check" width="541" height="224">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">classes().that().areAssignableTo(EntityManager.class)
    .should().onlyHaveDependentClassesThat().areAnnotatedWith(Transactional.class)</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_レイヤーのチェックlayer_checks"><a class="anchor" href="#_レイヤーのチェックlayer_checks"></a>4.6. レイヤーのチェック（Layer Checks）</h3>
<div class="imageblock">
<div class="content">
<img src="layer-check.png" alt="layer check" width="608" height="580">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">layeredArchitecture()
    .layer("Controller").definedBy("..controller..")
    .layer("Service").definedBy("..service..")
    .layer("Persistence").definedBy("..persistence..")

    .whereLayer("Controller").mayNotBeAccessedByAnyLayer()
    .whereLayer("Service").mayOnlyBeAccessedByLayers("Controller")
    .whereLayer("Persistence").mayOnlyBeAccessedByLayers("Service")</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_循環のチェックcycle_checks"><a class="anchor" href="#_循環のチェックcycle_checks"></a>4.7. 循環のチェック（Cycle Checks）</h3>
<div class="imageblock">
<div class="content">
<img src="cycle-check.png" alt="cycle check" width="700" height="378">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">slices().matching("com.myapp.(*)..").should().beFreeOfCycles()</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_考え方と概念ideas_and_concepts"><a class="anchor" href="#_考え方と概念ideas_and_concepts"></a>5. 考え方と概念（Ideas and Concepts）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>ArchUnit is divided into different layers, where the most important ones are the "Core" layer,
the "Lang" layer and the "Library" layer. In short the Core layer deals with the basic
infrastructure, i.e. how to import byte code into Java objects. The Lang layer contains the
rule syntax to specify architecture rules in a succinct way. The Library layer contains
more complex predefined rules, like a layered architecture with several layers. The following
section will explain these layers in more detail.</p>
</div>
<div class="paragraph">
<p>ArchUnit は複数のレイヤーに分かれています。
最も重要なレイヤーは「コアレイヤー」「言語レイヤー」「ライブラリレイヤー」です。
「コアレイヤー」はバイトコードを Java オブジェクトにインポートする等の基本的な部品を含みます。
「言語レイヤー」はアーキテクチャルールを簡潔に表現するルール構文を含みます。
「ライブラリレイヤー」はいくつものレイヤーで構成されるレイヤーアーキテクチャのように、より複雑な定義済みルールを含みます。
このセクションではそれぞれのレイヤーについてより詳しく説明します。</p>
</div>
<div class="sect2">
<h3 id="_コアレイヤーcore"><a class="anchor" href="#_コアレイヤーcore"></a>5.1. コアレイヤー（Core）</h3>
<div class="paragraph">
<p>Much of ArchUnit&#8217;s core API resembles the Java Reflection API.
There are classes like <code>JavaMethod</code>, <code>JavaField</code>, and more,
and the public API consists of methods like <code>getName()</code>, <code>getMethods()</code>,
<code>getRawType()</code> or <code>getRawParameterTypes()</code>.
Additionally ArchUnit extends this API for concepts needed to talk about dependencies between code,
like <code>JavaMethodCall</code>, <code>JavaConstructorCall</code> or <code>JavaFieldAccess</code>.
For example, it is possible to programmatically iterate over <code>javaClass.getAccessesFromSelf()</code>
and react to the imported accesses between this Java class and other Java classes.</p>
</div>
<div class="paragraph">
<p>ArchUnit のコア API の大部分は Java のリフレクション API とよく似た形式になっています。
<code>JavaMethod</code> や <code>JavaField</code> などのクラスがありますし、<code>getName()</code> や <code>getMethods()</code>、<code>getRawType()</code> や <code>getRawParameterTypes()</code> 等のパブリック API （メソッド）があります。
ArchUnit は、コード間の依存関係を表現するために必要な <code>JavaMethodCall</code> や <code>JavaConstructorCall</code> や <code>JavaFieldAccess</code> 等、これらの API の考え方を拡張しています。
例えば、<code>javaClass.getAccessesFromSelf()</code> のように記述すれば、<code>javaClass</code> そのものと他のクラスの間に存在する内向きのアクセスを処理できるのです。</p>
</div>
<div class="paragraph">
<p>To import compiled Java class files, ArchUnit provides the <code>ClassFileImporter</code>, which can
for example be used to import packages from the classpath:</p>
</div>
<div class="paragraph">
<p>コンパイルされた Java のクラスファイルをインポートするため、ArchUnit は <code>ClassFileImporter</code> を提供しています。
このクラスは、クラスパスに存在するパッケージに所属するクラスをインポートできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaClasses classes = new ClassFileImporter().importPackages("com.mycompany.myapp");</code></pre>
</div>
</div>
<div class="paragraph">
<p>For more information refer to <a href="#_コア_apithe_core_api">The Core API</a>.</p>
</div>
<div class="paragraph">
<p>より詳しい内容は <a href="#_コア_apithe_core_api">The Core API</a> を参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="_言語レイヤーlang"><a class="anchor" href="#_言語レイヤーlang"></a>5.2. 言語レイヤー（Lang）</h3>
<div class="paragraph">
<p>The Core API is quite powerful and offers a lot of information about the static structure
of a Java program. However, tests directly using the Core API lack expressiveness,
in particular with respect to architectural rules.</p>
</div>
<div class="paragraph">
<p>コア API は、Java プログラムの静的な構造に関するさまざまな情報を取得するための強力な機能を提供します。
しかし、テストコードから直接コア API を使うようにすると、特にアーキテクチャルールについて（意図の）表現力が損なわれてしまいます。</p>
</div>
<div class="paragraph">
<p>For this reason ArchUnit provides the Lang API, which offers a powerful syntax to express rules
in an abstract way. Most parts of the Lang API are composed as fluent APIs, i.e. an IDE can
provide valuable suggestions on the possibilities the syntax offers.</p>
</div>
<div class="paragraph">
<p>ArchUnit はこの問題を解決するため、より抽象的な形式でルールを表現する強力な構文を、言語 API として提供しています。
言語 API の大部分はフルーエント API として組み合わせるものになります。
そうすると、IDE は利用可能な構文の候補を提供できるのです。</p>
</div>
<div class="paragraph">
<p>An example for a specified architecture rule would be:</p>
</div>
<div class="paragraph">
<p>次の例は、具体的なアーキテクチャルールの1つです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">ArchRule rule =
    classes().that().resideInAPackage("..service..")
        .should().onlyBeAccessed().byAnyPackage("..controller..", "..service..");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Once a rule is composed, imported Java classes can be checked against it:</p>
</div>
<div class="paragraph">
<p>定義したルールは、インポートした Java クラスをチェックできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaClasses importedClasses = new ClassFileImporter().importPackage("com.myapp");
ArchRule rule = // define the rule
rule.check(importedClasses);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The syntax ArchUnit provides is fully extensible and can thus be adjusted to almost any
specific need. For further information, please refer to <a href="#_言語_apithe_lang_api">The Lang API</a>.</p>
</div>
<div class="paragraph">
<p>ArchUnit の提供する構文は全て拡張可能なので、あらゆる場面で必要に応じて調整できます。
より詳しい内容は <a href="#_言語_apithe_lang_api">The Lang API</a> を参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="_ライブラリレイヤーlibrary"><a class="anchor" href="#_ライブラリレイヤーlibrary"></a>5.3. ライブラリレイヤー（Library）</h3>
<div class="paragraph">
<p>The Library API offers predefined complex rules for typical architectural goals. For example
a succinct definition of a layered architecture via package definitions. Or rules to slice
the code base in a certain way, for example in different areas of the domain, and enforce these
slices to be acyclic or independent of each other. More detailed information is provided in
<a href="#_ライブラリ_apithe_library_api">The Library API</a>.</p>
</div>
<div class="paragraph">
<p>ライブラリ API は典型的なアーキテクチャを対象とする複雑な定義済みのルールを提供します。
例えば、パッケージ定義に基づく簡潔なレイヤーアーキテクチャのルールが挙げられます。
他にも、特定の断面でコードベースを横断するルールも定義されています。
例えば、さまざまな分野を反映したドメインや、それぞれの断面が循環しないように強制したり、それぞれの断面の独立性を高めたりするようなルールがあります。
より詳しい内容は <a href="#_ライブラリ_apithe_library_api">The Library API</a> を参照してください。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_コア_apithe_core_api"><a class="anchor" href="#_コア_apithe_core_api"></a>6. コア API（The Core API）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Core API is itself divided into the domain objects and the actual import.</p>
</div>
<div class="paragraph">
<p>コア API はドメインオブジェクトとインポートに関連する部分へ分かれています。</p>
</div>
<div class="sect2">
<h3 id="_インポートimport"><a class="anchor" href="#_インポートimport"></a>6.1. インポート（Import）</h3>
<div class="paragraph">
<p>As mentioned in <a href="#_考え方と概念ideas_and_concepts">Ideas and Concepts</a> the backbone of the infrastructure is the <code>ClassFileImporter</code>,
which provides various ways to import Java classes. One way is to import packages from
the classpath, or the complete classpath via</p>
</div>
<div class="paragraph">
<p><a href="#_考え方と概念ideas_and_concepts">Ideas and Concepts</a>でも説明したように、基本部品は <code>ClassFileImporter</code> クラスです。
このクラスは Java クラスファイルをインポートするためのさまざまな方法を提供します。
クラスパスに存在するパッケージを指定する方法や、完全なクラスパスを指定する方法があります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaClasses classes = new ClassFileImporter().importClasspath();</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, the import process is completely independent of the classpath, so it would be well possible
to import any path from the file system:</p>
</div>
<div class="paragraph">
<p>ただし、インポート処理自体はクラスパスと完全に独立しているため、ファイルシステム上の任意のパスを指定できるようになっています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaClasses classes = new ClassFileImporter().importPath("/some/path/to/classes");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>ClassFileImporter</code> offers several other methods to import classes, for example locations can be
specified as URLs or as JAR files.</p>
</div>
<div class="paragraph">
<p><code>ClassFileImporter</code> クラスは、クラスをインポートするためのさまざまな方法を提供しています。
例えば、URL や JAR ファイルでインポートする位置を指定できるようになっています。</p>
</div>
<div class="paragraph">
<p>Furthermore specific locations can be filtered out, if they are contained in the source of classes,
but should not be imported. A typical use case would be to ignore test classes, when the classpath
is imported. This can be achieved by specifying <code>ImportOptions</code>:</p>
</div>
<div class="paragraph">
<p>指定した位置の中から一部を除外できるようにもなっているため、インポートするべきではないクラスを無視できます。
テストクラスを除外するのはよくある使い方の1つです。
具体的には <code>ImportOptions</code> を指定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">ImportOption ignoreTests = new ImportOption() {
    @Override
    public boolean includes(Location location) {
        return !location.contains("/test/"); // ignore any URI to sources that contains '/test/'
    }
};

JavaClasses classes = new ClassFileImporter().withImportOption(ignoreTests).importClasspath();</code></pre>
</div>
</div>
<div class="paragraph">
<p>A <code>Location</code> is principally an URI, i.e. ArchUnit considers sources as File or JAR URIs</p>
</div>
<div class="paragraph">
<p>基本的に <code>Location</code> は URI として扱います。
ArchUnit は指定された <code>Location</code> を <code>File</code> あるいは <code>JAR</code> を指す <code>URI</code> として扱うということです。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><a href="file:///home/dev/my/project/target/classes/some/Thing.class" class="bare">file:///home/dev/my/project/target/classes/some/Thing.class</a></code></p>
</li>
<li>
<p><code>jar:file:///home/dev/.m2/repository/some/things.jar!/some/Thing.class</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the two common cases to skip importing JAR files and to skip importing test files
(for typical setups, like a Maven or Gradle build),
there already exist predefined <code>ImportOptions</code>:</p>
</div>
<div class="paragraph">
<p>Maven や Gradle のプロジェクトで一般的な2種類のケース、つまり、JARファイルやテストクラスをインポート対象から除外するケースは <code>ImportOptions</code> に定義済みです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">new ClassFileImporter()
    .withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_JARS)
    .withImportOption(ImportOption.Predefined.DO_NOT_INCLUDE_TESTS)
    .importClasspath();</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_存在しないクラスの扱いdealing_with_missing_classes"><a class="anchor" href="#_存在しないクラスの扱いdealing_with_missing_classes"></a>6.1.1. 存在しないクラスの扱い（Dealing with Missing Classes）</h4>
<div class="paragraph">
<p>While importing the requested classes (e.g. <code>target/classes</code> or <code>target/test-classes</code>)
it can happen that a class within the scope of the import has a reference to a class outside of the
scope of the import. This will naturally happen, if the classes of the JDK are not imported,
since then for example any dependency on <code>Object.class</code> will be unresolved within the import.</p>
</div>
<div class="paragraph">
<p><code>target/classes</code> や <code>target/test-classes</code> などを指定してインポートしたクラスが、指定した場所に存在しないクラスを参照している場合があります。
自然に発生する状況ですが、例えば JDK に含まれるクラスをインポートしていなければ、 <code>Object.class</code> に対する全ての依存関係は未解決になってしまいます。</p>
</div>
<div class="paragraph">
<p>At this point ArchUnit needs to decide how to treat these classes that are missing from the
import. By default, ArchUnit searches within the classpath for missing classes and if found
imports them. This obviously has the advantage that information about those classes
(which interfaces they implement, how they are annotated) is present during rule evaluation.</p>
</div>
<div class="paragraph">
<p>ArchUnit はインポートしたクラスに存在しないクラスを発見したときにどうするか決めておかなければなりません。
初期設定では存在しないクラスを発見したら、クラスパスを探索するようになっています。
ルールを評価するとき、実装しているインターフェイスやアノテーションなどの情報を利用できるのは大きな利点になります。</p>
</div>
<div class="paragraph">
<p>On the downside this additional lookup from the classpath will cost some performance and in some
cases might not make sense (e.g. if information about classes not present in the original import
is known to be unnecessary for evaluating rules).
Thus ArchUnit can be configured to create stubs instead, i.e. a <code>JavaClass</code> that has all the known
information, like the fully qualified name or the method called. However, this stub might
naturally lack some information, like superclasses, annotations or other details that cannot
be determined without importing the bytecode of this class. This behavior will also happen,
if ArchUnit fails to determine the location of a missing class from the classpath.</p>
</div>
<div class="paragraph">
<p>クラスパスを探索することの欠点は、時間が長くなってしまうことと無意味な結果しか得られない場合があることです。
例えば、インポートできたクラスに存在しないクラスの情報が、ルールの評価に不要なことが分かっている場合が挙げられます。
そういう場合について、ArchUnit ではスタブを生成できるようになっています。
具体的には <code>JavaClass</code> クラスは完全修飾名やメソッド呼び出しなど必要な全ての情報を持っています。
しかし、本質的にスタブには不足している情報があります。
基底クラスやアノテーション等、クラスファイル（バイトコード）をインポートしなければ決定できない情報のことです。
これは、ArchUnit がクラスパスを探索してもクラスを発見できなかった場合の振る舞いでもあります。</p>
</div>
<div class="paragraph">
<p>To find out, how to configure the default behavior, refer to <a href="#_解決のための振る舞いの構成configuring_the_resolution_behavior">Configuring the Resolution Behavior</a>.</p>
</div>
<div class="paragraph">
<p>振る舞いを変更する方法について知りたければ <a href="#_解決のための振る舞いの構成configuring_the_resolution_behavior">Configuring the Resolution Behavior</a> を参照してください。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ドメインdomain"><a class="anchor" href="#_ドメインdomain"></a>6.2. ドメイン（Domain）</h3>
<div class="paragraph">
<p>The domain objects represent Java code, thus the naming should be pretty straight forward. Most
commonly, the <code>ClassFileImporter</code> imports instances of type <code>JavaClass</code>. A rough overview looks
like this:</p>
</div>
<div class="paragraph">
<p>ドメインオブジェクトは Java のソースコードを直接的な名前で表現します。
ほとんどの場合 <code>ClassFileImporter</code> は <code>JavaClass</code> 型のインスタンスをインポートします。
基本的な構造は次のとおりです。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="domain-overview.png" alt="domain overview" width="935" height="698">
</div>
</div>
<div class="paragraph">
<p>Most objects resemble the Java Reflection API, including inheritance relations. Thus a <code>JavaClass</code>
has <code>JavaMembers</code>, which can in turn be either <code>JavaField</code>, <code>JavaMethod</code>,
<code>JavaConstructor</code> (or <code>JavaStaticInitializer</code>). While not present within the reflection API,
it makes sense to introduce an expression for anything that can access other code, which ArchUnit
calls 'code unit', and is in fact either a method, a constructor (including the class initializer)
or a static initializer of a class (e.g. a <code>static { &#8230;&#8203; }</code> block, a static field assignment,
etc.).</p>
</div>
<div class="paragraph">
<p>ほとんどのオブジェクトは、継承関係も含めて Java のリフレクション API とよく似た形式になっています。
<code>JavaClass</code> は <code>JavaMembers</code> を持っているし、<code>JavaMembers</code> は <code>JavaField</code> や <code>JavaMethod</code> や <code>JavaConstructor</code> （あるいは <code>JavaStaticInitializer</code>）のいずれかになります。
リフレクション API には存在しませんが、他のコードへアクセスする表現はあると便利です。
ArchUnit では「コードユニット（code unit）」と呼んでいる要素で、メソッドやコンストラクタ、クラスイニシャライザ、静的イニシャライザ（<code>static { &#8230;&#8203; }</code> ブロックやクラスフィールドの初期化など）に対応します。</p>
</div>
<div class="paragraph">
<p>Furthermore one of the most interesting features of ArchUnit that exceeds the Java Reflection API,
is the concept of accesses to another class. On the lowest level accesses can only take place
from a code unit (as mentioned, any block of executable code) to either a field (<code>JavaFieldAccess</code>),
a method (<code>JavaMethodCall</code>) or constructor (<code>JavaConstructorCall</code>).</p>
</div>
<div class="paragraph">
<p>ArchUnit が Java リフレクション API を拡張している中で最も面白い機能は他のクラスへのアクセス、という考え方です。
最も抽象度が低いのは、コードユニットからフィールド（<code>JavaFieldAccess</code>）やメソッド（<code>JavaMethodCall</code>）やコンストラクタ（<code>JavaConstructorCall</code>）に対するアクセスです。</p>
</div>
<div class="paragraph">
<p>ArchUnit imports the whole graph of classes and their relationship to each other. While checking
the accesses <strong>from</strong> a class is pretty isolated (the bytecode offers all this information),
checking accesses <strong>to</strong> a class requires the whole graph to be built first. To distinguish which
sort of access is referred to, methods will always clearly state <strong>fromSelf</strong> and <strong>toSelf</strong>.
For example, every <code>JavaField</code> allows to call <code>JavaField#getAccessesToSelf()</code> to retrieve all
code units within the graph that access this specific field. The resolution process through
inheritance is not completely straight forward. Consider for example</p>
</div>
<div class="paragraph">
<p>ArchUnit は全てのクラスの呼び出しグラフとクラス間の関係性を別々にインポートします。
<strong>アクセス元</strong> のクラスに対するチェックは完全に独立しています（全ての情報はバイトコードから取得します）が、 <strong>アクセス先</strong> のクラスをチェックするには最初に構築したグラフ情報が必要です。
どちらからアクセスしているのか区別するため、それぞれのメソッドは <strong>fromSelf</strong> と <strong>toSelf</strong> の状態を持つようになっています。
例えば、全ての <code>JavaField</code> は <code>JavaField#getAccessesToSelf()</code> でそのフィールドへアクセスするグラフ中の全てのコードユニットを取得できるようになっています。
継承関係のあるクラスにおける呼び出し元の解決処理は極めて複雑です。
次のような例を考えてみてください。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="resolution-example.png" alt="resolution example" width="358" height="190">
</div>
</div>
<div class="paragraph">
<p>The bytecode will record a field access from <code>ClassAccessing.accessField()</code> to
<code>ClassBeingAccessed.accessedField</code>. However, there is no such field, since the field is
actually declared in the superclass. This is the reason why a <code>JavaFieldAccess</code>
has no <code>JavaField</code> as its target, but a <code>FieldAccessTarget</code>. In other words, ArchUnit models
the situation, as it is found within the bytecode, and an access target is not an actual
member within another class. If a member is queried for <code>accessesToSelf()</code> though, ArchUnit
will resolve the necessary targets and determine, which member is represented by which target.
The situation looks roughly like</p>
</div>
<div class="paragraph">
<p>バイトコードには <code>ClassAccessing.accessField()</code> から <code>ClassBeingAccessed.accessedField</code> へアクセスしていることが記録されているでしょう。
しかし、実際にはそんなフィールドは存在しません。
基底クラスで定義されているからです。
<code>JavaFieldAccess</code> の対象に1つも <code>JavaField</code> が含まれておらず、<code>FieldAccessTarget</code> が存在するのはそのせいです。
別の言い方をすると、ArchUnit はバイトコードから得られた状況をモデル化していると言えます。
アクセスしている対象自体はそのクラスのメンバーではないのです。
メンバーを <code>accessToSelf()</code> で問い合わせれば、ArchUnit は必要な対象を発見、特定できます。
対象自体がメンバーを表現しているからです。
例えば次のような状況です。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="resolution-overview.png" alt="resolution overview" width="506" height="320">
</div>
</div>
<div class="paragraph">
<p>Two things might seem strange at the first look.</p>
</div>
<div class="paragraph">
<p>一見すると奇妙なところが2点見つけられます。</p>
</div>
<div class="paragraph">
<p>First, why can a target resolve to zero matching members? The reason is that the set of classes
that was imported does not need to have all classes involved within this resolution process.
Consider the above example, if <code>SuperclassBeingAccessed</code> would not be imported, ArchUnit would
have no way of knowing where the actual targeted field resides. Thus in this case the
resolution would return zero elements.</p>
</div>
<div class="paragraph">
<p>1点目は、対象を解決した結果となるメンバー数が0になる場合があることです。
原因は、インポートしたクラスに、この解決処理に関係する全てのクラスが必要だとは限らないからです。
前の例では <code>SuperclassBeingAccessed</code> がインポートされていますが、ArchUnit には実際にどのようなフィールドが存在するのか知る手段がありません。
だから、解決結果の要素数が0になる場合があるのです。</p>
</div>
<div class="paragraph">
<p>Second, why can there be more than one resolved methods for method calls?
The reason for this is that a call target might indeed match several methods in those
cases, for example:</p>
</div>
<div class="paragraph">
<p>2点目は、メソッド呼び出しを解決した結果が1以上になる場合があることです。
原因は、実際に対象のメソッドが複数回呼び出されている場合があることです。
例えば次のような場合があります。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="diamond-example.png" alt="diamond example" width="463" height="229">
</div>
</div>
<div class="paragraph">
<p>While this situation will always be resolved in a specified way for a real program,
ArchUnit cannot do the same. Instead, the resolution will report all candidates that match a
specific access target, so in the above example, the call target <code>C.targetMethod()</code> would in fact
resolve to two <code>JavaMethods</code>, namely <code>A.targetMethod()</code> and <code>B.targetMethod()</code>. Likewise a check
of either <code>A.targetMethod.getCallsToSelf()</code> or <code>B.targetMethod.getCallsToSelf()</code> would return
the same call from <code>D.callTargetMethod()</code> to <code>C.targetMethod()</code>.</p>
</div>
<div class="paragraph">
<p>実際のプログラムなら常に特別な方法で解決するような状況ですが、ArchUnit には解決できません。
代わりに、具体的なアクセス対象にマッチする全ての候補を報告します。
前の例では呼び出し対象の <code>C.targetMethod()</code> について、<code>A.targetMethod()</code> および <code>B.targetMethod()</code> という2つの <code>JavaMethods</code> を報告します。
同様に、<code>A.targetMethod.getCallsToSelf()</code> や <code>B.targetMethod.getCallsToSelf()</code> のどちらも、<code>D.callTargetMethod()</code> から <code>C.targetMethod()</code> と同じ呼び出し対象を返すことになります。</p>
</div>
<div class="sect3">
<h4 id="_ドメインオブジェクトリフレクションクラスパスdomain_objects_reflection_and_the_classpath"><a class="anchor" href="#_ドメインオブジェクトリフレクションクラスパスdomain_objects_reflection_and_the_classpath"></a>6.2.1. ドメインオブジェクト、リフレクション、クラスパス（Domain Objects, Reflection and the Classpath）</h4>
<div class="paragraph">
<p>ArchUnit tries to offer a lot of information from the bytecode. For example, a <code>JavaClass</code>
provides details like if it is an enum or an interface, modifiers like <code>public</code> or <code>abstract</code>,
but also the source, where this class was imported from (namely the URI mentioned in the first
section). However, if information is missing, and the classpath is correct, ArchUnit offers
some convenience to rely on the reflection API for extended details. For this reason, most
<code>Java*</code> objects offer a method <code>reflect()</code>, which will in fact try to resolve the respective
object from the Reflection API. For example:</p>
</div>
<div class="paragraph">
<p>ArchUnit はバイトコードから取得した多くの情報をできるだけ提供できるように試みます。
例えば、<code>JavaClass</code> ならそれが enum なのか interface なのか教えてくれるし、<code>public</code> 修飾子や <code>abstract</code> 修飾子についても教えてくれます。
また、どこからインポートしたクラスなのかも教えてくれます（前のセクションで説明した URI のことです）。
そして、正しいクラスパスが与えられているのに情報が欠落している場合、ArchUnit はリフレクション API を駆使して更なる詳細の提供を試みます。
ほとんどの <code>Java*</code> オブジェクトには <code>reflect()</code> メソッドが存在するのはそのためです。
このメソッドはリフレクション API でオブジェクトの情報を解決しようとします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaClasses classes = new ClassFileImporter().importClasspath(new ImportOptions());

// ArchUnit's java.lang.String
JavaClass javaClass = classes.get(String.class);
// Reflection API's java.lang.String
Class&lt;?&gt; stringClass = javaClass.reflect();

// ArchUnit's public int java.lang.String.length()
JavaMethod javaMethod = javaClass.getMethod("length");
// Reflection API's public int java.lang.String.length()
Method lengthMethod = javaMethod.reflect();</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, this will throw an <code>Exception</code>, if the respective classes are missing on the classpath
(e.g. because they were just imported from some file path).</p>
</div>
<div class="paragraph">
<p>ただし、対応するクラスがクラスパス上に存在しない場合（ファイルパスからインポートした場合等）、このメソッドは <code>Exception</code> を送出します。</p>
</div>
<div class="paragraph">
<p>This restriction also applies to handling annotations in a more convenient way.
Consider the following annotation:</p>
</div>
<div class="paragraph">
<p>この制限は、アノテーションをより便利に扱う方法を提供します。
例えば、次のようなアノテーションがあるとします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@interface CustomAnnotation {
    String value();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to access this annotation without it being on the classpath, you must rely on</p>
</div>
<div class="paragraph">
<p>このアノテーションがクラスパス上に存在しなくてもアクセスしなければならないときは次のようにするしかありません。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaAnnotation&lt;?&gt; annotation = javaClass.getAnnotationOfType("some.pkg.CustomAnnotation");
// result is untyped, since it might not be on the classpath (e.g. enums)
Object value = annotation.get("value");</code></pre>
</div>
</div>
<div class="paragraph">
<p>So there is neither type safety nor automatic refactoring support. If this annotation is on the classpath, however,
this can be written way more naturally:</p>
</div>
<div class="paragraph">
<p>この場合型安全性は保証されませんし、自動的なリファクタリング支援も得られません。
アノテーションがクラスパス上に存在するなら、次のようにより自然に記述できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">CustomAnnotation annotation = javaClass.getAnnotationOfType(CustomAnnotation.class);
String value = annotation.value();</code></pre>
</div>
</div>
<div class="paragraph">
<p>ArchUnit&#8217;s own rule APIs (compare <a href="#_言語_apithe_lang_api">The Lang API</a>) never rely on the
classpath though. Thus the evaluation of default rules and syntax combinations, described in the
next section, does not depend on whether the classes were imported from the classpath or
some JAR / folder.</p>
</div>
<div class="paragraph">
<p>ArchUnit 自身のルール API （<a href="#_言語_apithe_lang_api">The Lang API</a> を参照）はクラスパスに依存していません。
つまり、次のセクションで説明する、基本ルールやルール構文の組み合わせを評価するときは、クラスパスやJARあるいはフォルダのどこからクラスをインポートしても関係ないのです。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_言語_apithe_lang_api"><a class="anchor" href="#_言語_apithe_lang_api"></a>7. 言語 API（The Lang API）</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_クラスルールの合成composing_class_rules"><a class="anchor" href="#_クラスルールの合成composing_class_rules"></a>7.1. クラスルールの合成（Composing Class Rules）</h3>
<div class="paragraph">
<p><a href="#_コア_apithe_core_api">The Core API</a> is pretty powerful with regard to all the details from the bytecode
that it provides to tests. However, tests written this way lack conciseness and fail to convey the
architectural concept that they should assert. Consider:</p>
</div>
<div class="paragraph">
<p><a href="#_コア_apithe_core_api">The Core API</a> はテストするためにインポートしたバイトコードに関するあらゆる情報を扱えるため、とても強力です。
しかし、コア API で記述したテストは簡潔とは言い難く、検証するべきアーキテクチャとしての考え方を上手く伝えられない場合があります。
次のソースコードを検討してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">Set&lt;JavaClass&gt; services = new HashSet&lt;&gt;();
for (JavaClass clazz : classes) {
    // choose those classes with FQN with infix '.service.'
    if (clazz.getName().contains(".service.")) {
        services.add(clazz);
    }
}

for (JavaClass service : services) {
    for (JavaAccess&lt;?&gt; access : service.getAccessesFromSelf()) {
        String targetName = access.getTargetOwner().getName();

        // fail if the target FQN has the infix ".controller."
        if (targetName.contains(".controller.")) {
            String message = String.format(
                    "Service %s accesses Controller %s in line %d",
                    service.getName(), targetName, access.getLineNumber());
            Assert.fail(message);
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What we want to express, is the rule <em>"no classes that reside in a package 'service' should
access classes that reside in a package 'controller'"</em>. Nevertheless, it&#8217;s hard to read through
that code and distill that information. And the same process has to be done every time someone
needs to understand the semantics of this rule.</p>
</div>
<div class="paragraph">
<p>表現したいのは <em>「パッケージ名に 'service' を含むクラスはパッケージ名に 'controller' を含むクラスへアクセスしてはならない」</em> というルールです。
しかし、このソースコードからそのような意図を読み取るのは困難です。
それに、このルールの意味を理解しなければならない人は全員が同じ困難なプロセスを体験しなければなりません。</p>
</div>
<div class="paragraph">
<p>To solve this shortcoming, ArchUnit offers a high level API to express architectural concepts
in a concise way. In fact, we can write code that is almost equivalent to the prose rule text
mentioned before:</p>
</div>
<div class="paragraph">
<p>この問題を解決するため、ArchUnit はアーキテクチャとしての考え方を分かりやすく表現するための高水準 API を提供しています。
この API を使用すると、前に説明した文章のようにルールを記述できるのです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">ArchRule rule = ArchRuleDefinition.noClasses()
    .that().resideInAPackage("..service..")
    .should().accessClassesThat().resideInAPackage("..controller..");

rule.check(importedClasses);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The only difference to colloquial language is the ".." in the package notation,
which refers to any number of packages. Thus "..service.." just expresses
<em>"any package that contains some sub-package 'service'"</em>, e.g. <code>com.myapp.service.any</code>.
If this test fails, it will report an <code>AssertionError</code> with the following message:</p>
</div>
<div class="paragraph">
<p>話し言葉との違いはパッケージ記法に含まれる ".." で、これは任意のパッケージを表しています。
つまり "..service.." は <em>「サブパッケージ 'service' を含む任意のパッケージ」</em> という意味になるのです。
例えば <code>com.myapp.service.any</code> などが挙げられます。
このテストが失敗するときは、次のようなメッセージを含む <code>AssertionError</code> を報告するでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="bash" class="language-bash hljs">java.lang.AssertionError: Architecture Violation [Priority: MEDIUM] -
Rule 'no classes that reside in a package '..service..'
should access classes that reside in a package '..controller..'' was violated (1 times):
Method &lt;some.pkg.service.SomeService.callController()&gt;
calls method &lt;some.pkg.controller.SomeController.execute()&gt;
in (SomeService.java:14)</code></pre>
</div>
</div>
<div class="paragraph">
<p>So as a benefit, the assertion error contains the full rule text out of the box and reports
all violations including the exact class and line number. The rule API also allows to combine
predicates and conditions:</p>
</div>
<div class="paragraph">
<p>表明エラーは、定義済みのルールに関する完全な文章を含んでおり、正確なクラス名と行番号を含む全ての違反を報告します。
ルール API は述語式と条件式を組み合わせることができるようになっています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">noClasses()
    .that().resideInAPackage("..service..")
    .or().resideInAPackage("..persistence..")
    .should().accessClassesThat().resideInAPackage("..controller..")
    .orShould().accessClassesThat().resideInAPackage("..ui..")

rule.check(importedClasses);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_メンバールールの合成composing_member_rules"><a class="anchor" href="#_メンバールールの合成composing_member_rules"></a>7.2. メンバールールの合成（Composing Member Rules）</h3>
<div class="paragraph">
<p>In addition to a predefined API to write rules about Java classes and their relations, there is
an extended API to define rules for members of Java classes. This might be relevant, for example,
if methods in a certain context need to be annotated with a specific annotation, or return
types implementing a certain interface. The entry point is again <code>ArchRuleDefinition</code>, e.g.</p>
</div>
<div class="paragraph">
<p>Java クラスとクラス間の関係を説明するルールを記述する定義済みの API に加えて、Java クラスのメンバーに関するルールを定義するための拡張 API があります。
それぞれの API は関連性があります。
例えば、あるメソッドは特定のコンテキストにおいて何らかのアノテーションで修飾しなければならないとか、メソッドの返り値の型は特定のインターフェイスを実装したクラスでなければならないとかです。
ルールの入口はやはり <code>ArchRuleDefinition</code> です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">ArchRule rule = ArchRuleDefinition.methods()
    .that().arePublic()
    .and().areDeclaredInClassesThat().resideInAPackage("..controller..")
    .should().beAnnotatedWith(Secured.class);

rule.check(importedClasses);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Besides <code>methods()</code>, <code>ArchRuleDefinition</code> offers the methods <code>members()</code>, <code>fields()</code>, <code>codeUnits()</code>, <code>constructors()</code>
– and the corresponding negations <code>noMembers()</code>, <code>noFields()</code>, <code>noMethods()</code>, etc.</p>
</div>
<div class="paragraph">
<p><code>ArchRuleDefinition</code> は、<code>methods()</code> に続けて <code>members()</code> <code>fields()</code> <code>codeUnits()</code> <code>constructors()</code> のようなメソッドと、それらの反対を意味する <code>noMembers()</code> <code>noFields()</code> <code>noMethods()</code> のようなメソッドを提供しています。</p>
</div>
</div>
<div class="sect2">
<h3 id="_独自ルールの作成creating_custom_rules"><a class="anchor" href="#_独自ルールの作成creating_custom_rules"></a>7.3. 独自ルールの作成（Creating Custom Rules）</h3>
<div class="paragraph">
<p>In fact, most architectural rules take the form</p>
</div>
<div class="paragraph">
<p>ほとんどのアーキテクチャとしてのルールは次のような形式になります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">classes that ${PREDICATE} should ${CONDITION}</code></pre>
</div>
</div>
<div class="paragraph">
<p>In other words, we always want to limit imported classes to a relevant subset,
and then evaluate some condition to see that all those classes satisfy it.
ArchUnit&#8217;s API allows you to do just that, by exposing the concepts of <code>DescribedPredicate</code> and <code>ArchCondition</code>.
So the rule above is just an application of this generic API:</p>
</div>
<div class="paragraph">
<p>別の言い方をしましょう。
私たちはバイトコードからインポートするクラスを関連するクラスだけに限定し、それらのクラスが指定した条件を満たしているのか評価するようにしたいのです。
ArchUnit は <code>DescribePredicate</code> および <code>ArchCondition</code> という API でそれを実現します。
この汎用 API で前のセクションに登場したルールを記述すると次のようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">DescribedPredicate&lt;JavaClass&gt; resideInAPackageService = // define the predicate
ArchCondition&lt;JavaClass&gt; accessClassesThatResideInAPackageController = // define the condition

noClasses().that(resideInAPackageService)
    .should(accessClassesThatResideInAPackageController);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thus, if the predefined API does not allow to express some concept,
it is possible to extend it in any custom way.
For example:</p>
</div>
<div class="paragraph">
<p>定義済みのルールで表現できない考え方があるとしても、例えば次のように拡張できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">DescribedPredicate&lt;JavaClass&gt; haveAFieldAnnotatedWithPayload =
    new DescribedPredicate&lt;JavaClass&gt;("have a field annotated with @Payload"){
        @Override
        public boolean apply(JavaClass input) {
            boolean someFieldAnnotatedWithPayload = // iterate fields and check for @Payload
            return someFieldAnnotatedWithPayload;
        }
    };

ArchCondition&lt;JavaClass&gt; onlyBeAccessedBySecuredMethods =
    new ArchCondition&lt;JavaClass&gt;("only be accessed by @Secured methods") {
        @Override
        public void check(JavaClass item, ConditionEvents events) {
            for (JavaMethodCall call : item.getMethodCallsToSelf()) {
                if (!call.getOrigin().isAnnotatedWith(Secured.class)) {
                    String message = String.format(
                        "Method %s is not @Secured", call.getOrigin().getFullName());
                    events.add(SimpleConditionEvent.violated(call, message));
                }
            }
        }
    };

classes().that(haveAFieldAnnotatedWithPayload).should(onlyBeAccessedBySecuredMethods);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the rule fails, the error message will be built from the supplied descriptions. In the
example above, it would be</p>
</div>
<div class="paragraph">
<p>ルールの評価が失敗したら、指定した説明文からエラーメッセージが構築されます。
前のコード例では次のようなエラーメッセージになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">classes that have a field annotated with @Payload should only be accessed by @Secured methods</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_定義済みの述語式と条件式predefined_predicates_and_conditions"><a class="anchor" href="#_定義済みの述語式と条件式predefined_predicates_and_conditions"></a>7.4. 定義済みの述語式と条件式（Predefined Predicates and Conditions）</h3>
<div class="paragraph">
<p>Custom predicates and conditions like in the last section can often be composed from predefined elements.
ArchUnit&#8217;s basic convention for predicates is that they are defined in an inner class <code>Predicates</code> within the type they target.
For example, one can find the predicate to check for the simple name of a <code>JavaClass</code> as</p>
</div>
<div class="paragraph">
<p>1つ前のセクションのように、独自の述語式や条件式は定義済みの部品を組み合わせて実現できる場合がよくあります。
ArchUnit の述語式は、基本的な規約として、評価対象のクラス（型）のインナークラス <code>Predicates</code> として定義するようになっています。
例えば、<code>JavaClass</code> における「簡潔な名前」という述語式は次のように見つけられます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">JavaClass.Predicates.simpleName(String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Predicates can be joined using the methods <code>predicate.or(other)</code> and <code>predicate.and(other)</code>.
So for example a predicate testing for a class with simple name "Foo" that is serializable
could be created the following way:</p>
</div>
<div class="paragraph">
<p>述語式は <code>predicate.or(other)</code> メソッドや <code>predicate.and(other)</code> メソッドで結合できます。
ですから、簡潔なクラス名が "Foo" なら、シリアライズ可能でなければならない、という述語式は次のように記述できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">import static com.tngtech.archunit.core.domain.JavaClass.Predicates.assignableTo;
import static com.tngtech.archunit.core.domain.JavaClass.Predicates.simpleName;

DescribedPredicate&lt;JavaClass&gt; serializableNamedFoo =
    simpleName("Foo").and(assignableTo(Serializable.class));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that for some properties, there exist interfaces with predicates defined for them.
For example the property to have a name is represented by the interface <code>HasName</code>;
consequently the predicate to check the name of a <code>JavaClass</code>
is the same as the predicate to check the name of a <code>JavaMethod</code>,
and resides within</p>
</div>
<div class="paragraph">
<p>一部のプロパティは述語式のために定義されたインターフェイスになっているので注意してください。
例えば、<code>JavaClass</code> と <code>JavaMethod</code> のどちらでも、名前をチェックするプロパティは <code>HasName</code> というインターフェイスになっています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">HasName.Predicates.name(String)</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can at times lead to problems with the type system, if predicates are supposed to be joined.
Since the <code>or(..)</code> method accepts a type of <code>DescribedPredicate&lt;? super T&gt;</code>,
where <code>T</code> is the type of the first predicate. For example:</p>
</div>
<div class="paragraph">
<p>これは、特に述語式を結合するとき、型システムとしての問題になる場合があります。
<code>or(..)</code> メソッドの引数の型は <code>DescribePredicate&lt;? super T&gt;</code> で、<code>T</code> は先頭の述語式になるからです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">// Does not compile, because type(..) targets a subtype of HasName
HasName.Predicates.name("").and(JavaClass.Predicates.type(Serializable.class))

// Does compile, because name(..) targets a supertype of JavaClass
JavaClass.Predicates.type(Serializable.class).and(HasName.Predicates.name(""))

// Does compile, because the compiler now sees name(..) as a predicate for JavaClass
DescribedPredicate&lt;JavaClass&gt; name = HasName.Predicates.name("").forSubtype();
name.and(JavaClass.Predicates.type(Serializable.class));</code></pre>
</div>
</div>
<div class="paragraph">
<p>This behavior is somewhat tedious, but unfortunately it is a shortcoming of the Java type system
that cannot be circumvented in a satisfying way.</p>
</div>
<div class="paragraph">
<p>この分かりにくい振る舞いは Java の型システムの欠点に起因するもので、残念ながら安全に回避する方法はありません。</p>
</div>
<div class="paragraph">
<p>Just like predicates, there exist predefined conditions that can be combined in a similar way.
Since <code>ArchCondition</code> is a less generic concept, all predefined conditions can be found within <code>ArchConditions</code>.
Examples:</p>
</div>
<div class="paragraph">
<p>述語式と同じように合成できる定義済みの条件式が、<code>ArchCondition</code> に定義されています。
ただし、<code>ArchCondition</code> はジェネリクスの考え方が少し薄くなっています。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">ArchCondition&lt;JavaClass&gt; callEquals =
    ArchConditions.callMethod(Object.class, "equals", Object.class);
ArchCondition&lt;JavaClass&gt; callHashCode =
    ArchConditions.callMethod(Object.class, "hashCode");

ArchCondition&lt;JavaClass&gt; callEqualsOrHashCode = callEquals.or(callHashCode);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_独自の考え方に基づくルールrules_with_custom_concepts"><a class="anchor" href="#_独自の考え方に基づくルールrules_with_custom_concepts"></a>7.5. 独自の考え方に基づくルール（Rules with Custom Concepts）</h3>
<div class="paragraph">
<p>Earlier we stated that most architectural rules take the form</p>
</div>
<div class="paragraph">
<p>前のセクションでほとんどのアーキテクチャとしてのルールは次のような形式になることを説明しました。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">classes that ${PREDICATE} should ${CONDITION}</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, we do not always talk about classes, if we express architectural concepts. We might
have custom language, we might talk about modules, about slices, or on the other hand more
detailed about fields, methods or constructors. A generic API will never be able to support
every imaginable concept out of the box. Thus ArchUnit&#8217;s rule API has at its foundation
a more generic API that controls the types of objects that our concept targets.</p>
</div>
<div class="paragraph">
<p>ところが、私たちはアーキテクチャとしての考え方を表現するとき、常にクラスについて言及しているわけではありません。
自作の言語やモジュール、コードの断面について言及する場合もあるし、フィールドやメソッドやコンストラクタの詳細について言及する場合もあるからです。
規定の汎用 API では、全ての想像上の概念を表現することは不可能です。
そのため、ArchUnit のルール API は、評価対象のオブジェクトの型を操作するより汎用性の高い API で構成されています。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="import-vs-lang.png" alt="import vs lang" width="653" height="85">
</div>
</div>
<div class="paragraph">
<p>To achieve this, any rule definition is based on a <code>ClassesTransformer</code> that defines how
<code>JavaClasses</code> are to be transformed to the desired rule input. In many cases, like the ones
mentioned in the sections above, this is the identity transformation, passing classes on to the rule
as they are. However, one can supply any custom transformation to express a rule about a
different type of input object. For example:</p>
</div>
<div class="paragraph">
<p>あらゆるルール定義は <code>ClassesTransformer</code> に基づいています。
これは、<code>JavaClasses</code> を適切なルールの入力へどのように変換するか定義します。
多くの場合、前のセクションで言及したように何も変更せず、クラスそのものをルールに渡すことになります。
しかし、異なる型を要求するルールにオブジェクトを渡せるよう、独自の変換処理を定義する場合もあります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">ClassesTransformer&lt;JavaPackage&gt; packages = new AbstractClassesTransformer&lt;JavaPackage&gt;("packages") {
    @Override
    public Iterable&lt;JavaPackage&gt; doTransform(JavaClasses classes) {
        Set&lt;JavaPackage&gt; result = new HashSet&lt;&gt;();
        classes.getDefaultPackage().accept(alwaysTrue(), new PackageVisitor() {
            @Override
            public void visit(JavaPackage javaPackage) {
                result.add(javaPackage);
            }
        });
        return result;
    }
};

all(packages).that(containACoreClass()).should(...);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Of course these transformers can represent any custom concept desired:</p>
</div>
<div class="paragraph">
<p>もちろん、そういった変換で独自の考え方を表現できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">// how we map classes to business modules
ClassesTransformer&lt;BusinessModule&gt; businessModules = ...

// filter business module dealing with orders
DescribedPredicate&lt;BusinessModule&gt; dealWithOrders = ...

// check that the actual business module is independent of payment
ArchCondition&lt;BusinessModule&gt; beIndependentOfPayment = ...

all(businessModules).that(dealWithOrders).should(beIndependentOfPayment);</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ルールの文章を制御するcontrolling_the_rule_text"><a class="anchor" href="#_ルールの文章を制御するcontrolling_the_rule_text"></a>7.6. ルールの文章を制御する（Controlling the Rule Text）</h3>
<div class="paragraph">
<p>If the rule is straight forward, the rule text that is created automatically should be
sufficient in many cases. However, for rules that are not common knowledge, it is good practice
to document the reason for this rule. This can be done in the following way:</p>
</div>
<div class="paragraph">
<p>分かりやすいルールなら、自動的に生成されるルールの説明文で十分な場合が多いでしょう。
しかし、共通知識とは言えないルールについて、根拠をドキュメント化しておくのは良いプラクティスです。
例えば、次のように記述できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">classes().that(haveAFieldAnnotatedWithPayload).should(onlyBeAccessedBySecuredMethods)
    .because("@Secured methods will be intercepted, checking for increased privileges " +
        "and obfuscating sensitive auditing information");</code></pre>
</div>
</div>
<div class="paragraph">
<p>Nevertheless, the generated rule text might sometimes not convey the real intention
concisely enough, e.g. if multiple predicates or conditions are joined.
It is possible to completely overwrite the rule description in those cases:</p>
</div>
<div class="paragraph">
<p>とはいえ、自動的に生成したルールの説明文が、本来の意図を十分に簡潔に表現できていない場合もあるでしょう。
複数の述語式や条件式を結合した場合は特にそうです。
そういうときは、ルールの説明文を全て置き換えることができます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">classes().that(haveAFieldAnnotatedWithPayload).should(onlyBeAccessedBySecuredMethods)
    .as("Payload may only be accessed in a secure way");</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_違反を無視するignoring_violations"><a class="anchor" href="#_違反を無視するignoring_violations"></a>7.7. 違反を無視する（Ignoring Violations）</h3>
<div class="paragraph">
<p>In legacy projects there might be too many violations to fix at once. Nevertheless, that code
should be covered completely by architecture tests to ensure that no further violations will
be added to the existing code. One approach to ignore existing violations is
to tailor the <code>that(..)</code> clause of the rules in question to ignore certain violations.
A more generic approach is to ignore violations based on simple regex matches.
For this one can put a file named <code>archunit_ignore_patterns.txt</code> in the root of the classpath.
Every line will be interpreted as a regular expression and checked against reported violations.
Violations with a message matching the pattern will be ignored. If no violations are left,
the check will pass.</p>
</div>
<div class="paragraph">
<p>レガシープロジェクトでは1度に直しきれないほど多数の違反が見つかるものです。
とはいえ、既存のコードに新しい違反を持ち込むことがないよう、違反しているコードもアーキテクチャテストの対象にしなければなりません。
既存の違反を無視する1つのやり方として、ルールの <code>that(..)</code> 節を調整する方法があります。
より汎用的な解決方法は、単純に正規表現で一致させる方法です。
クラスパスのルートに <code>archunit_ignore_patterns.txt</code> というテキストファイルを配置し、それぞれの行には、報告された違反にマッチする正規表現を記述します。
違反のメッセージがいずれかの正規表現に一致するなら、その違反を無視するようになります。
違反が1つも無くなれば、チェックは成功します。</p>
</div>
<div class="paragraph">
<p>For example, suppose the class <code>some.pkg.LegacyService</code> violates a lot of different rules.
It is possible to add</p>
</div>
<div class="paragraph">
<p>例えば、<code>some.pkg.LegacyService</code> というクラスがいくつものルールに違反しているとしたら、次のような正規表現を追加すればいいでしょう。</p>
</div>
<div class="listingblock">
<div class="title">archunit_ignore_patterns.txt</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="bash" class="language-bash hljs">.*some\.pkg\.LegacyService.*</code></pre>
</div>
</div>
<div class="paragraph">
<p>All violations mentioning <code>some.pkg.LegacyService</code> will consequently be ignored, and rules that
are only violated by such violations will report success instead of failure.</p>
</div>
<div class="paragraph">
<p><code>some.pkg.LegacyService</code> に言及する全ての違反が無視されるようになります。
そうして、他の違反が見つからなければ、失敗ではなく成功と報告するようになります。</p>
</div>
<div class="paragraph">
<p>It is possible to add comments to ignore patterns by prefixing the line with a '\#':</p>
</div>
<div class="paragraph">
<p>行頭に <code>\#</code> を指定することで、正規表現の内容を説明するコメントを記述できます。</p>
</div>
<div class="listingblock">
<div class="title">archunit_ignore_patterns.txt</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="bash" class="language-bash hljs"># There are many known violations where LegacyService is involved; we'll ignore them all
.*some\.pkg\.LegacyService.*</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_ライブラリ_apithe_library_api"><a class="anchor" href="#_ライブラリ_apithe_library_api"></a>8. ライブラリ API（The Library API）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Library API offers a growing collection of predefined rules, which offer a more concise API
for more complex but common patterns, like a layered architecture or checks for cycles between
slices (compare <a href="#_チェックの対象what_to_check">What to Check</a>).</p>
</div>
<div class="paragraph">
<p>ライブラリ API は発展途上の定義済みのルール集合を提供します。
レイヤーアーキテクチャや、ソースコード断面の循環チェック（<a href="#_チェックの対象what_to_check">What to Check</a>も参照）のように、複雑だけど一般的なパターンに関する簡潔な API を提供するのです。</p>
</div>
<div class="sect2">
<h3 id="_アーキテクチャarchitectures"><a class="anchor" href="#_アーキテクチャarchitectures"></a>8.1. アーキテクチャ（Architectures）</h3>
<div class="paragraph">
<p>The entrance point for checks of common architectural styles is:</p>
</div>
<div class="paragraph">
<p><code>Architectures</code> は一般的なアーキテクチャスタイルに関するチェックの入口です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">com.tngtech.archunit.library.Architectures</code></pre>
</div>
</div>
<div class="paragraph">
<p>At the moment this only provides a convenient check for a layered architecture and onion architecture.
But in the future it might be extended for styles like a pipes and filters,
separation of business logic and technical infrastructure, etc.</p>
</div>
<div class="paragraph">
<p>現時点では、レイヤーアーキテクチャとオニオンアーキテクチャに関する便利なチェックしか提供していません。
将来的にはパイプ・フィルタースタイルや、「業務ロジックと技術要素の分離（separation of business logic and technical infrastructure）」スタイルにも対応する予定です。</p>
</div>
<div class="sect3">
<h4 id="_レイヤーアーキテクチャlayered_architecture"><a class="anchor" href="#_レイヤーアーキテクチャlayered_architecture"></a>8.1.1. レイヤーアーキテクチャ（Layered Architecture）</h4>
<div class="paragraph">
<p>In layered architectures, we define different layers and how those interact with each other.
An example setup for a simple 3-tier architecture can be found in <a href="#_レイヤーのチェックlayer_checks">Layer Checks</a>.</p>
</div>
<div class="paragraph">
<p>「レイヤーアーキテクチャ」では、いくつものレイヤーを定義し、それぞれのレイヤーのやりとりを定義できます。
単純な3層アーキテクチャの例を <a href="#_レイヤーのチェックlayer_checks">Layer Checks</a> で説明しています。</p>
</div>
</div>
<div class="sect3">
<h4 id="_オニオンアーキテクチャonion_architecture"><a class="anchor" href="#_オニオンアーキテクチャonion_architecture"></a>8.1.2. オニオンアーキテクチャ（Onion Architecture）</h4>
<div class="paragraph">
<p>In an "Onion Architecture" (also known as "Hexagonal Architecture" or "Ports and Adapters"),
we can define domain packages and adapter packages as follows.</p>
</div>
<div class="paragraph">
<p>「オニオンアーキテクチャ」（「ポート・アダプター」あるいは「ヘキサゴナルアーキテクチャ」として知られている）では、ドメインとアダプターのためのパッケージを次のように定義できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">onionArchitecture()
        .domainModels("com.myapp.domain.model..")
        .domainServices("com.myapp.domain.service..")
        .applicationServices("com.myapp.application..")
        .adapter("cli", "com.myapp.adapter.cli..")
        .adapter("persistence", "com.myapp.adapter.persistence..")
        .adapter("rest", "com.myapp.adapter.rest..");</code></pre>
</div>
</div>
<div class="paragraph">
<p>The semantic follows the descriptions in <a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/" class="bare">https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/</a>.
More precisely, the following holds:</p>
</div>
<div class="paragraph">
<p>それぞれの意味については <a href="https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/" class="bare">https://jeffreypalermo.com/2008/07/the-onion-architecture-part-1/</a> を参照してください。
ここでは次のような意味を表しています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>domain</code> パッケージ - アプリケーションの中核です。次のような部品を含んでいます</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>domainModels</code> パッケージ - ドメインエンティティを配置します</p>
</li>
<li>
<p><code>domainServices</code> パッケージ - ドメインエンティティを使用するサービスを配置します</p>
</li>
</ol>
</div>
</li>
<li>
<p><code>applicationServices</code> パッケージ - アプリケーションとユースケースを実行するためのサービスおよび設定を配置します。
<code>domain</code> パッケージに配置した要素を使用しますが、<code>domain</code> パッケージに配置した要素から <code>application</code> パッケージに配置した要素は使用できません</p>
</li>
<li>
<p><code>adapter</code> パッケージ - 外部システムやインフラへ接続するためのロジックを配置します。
アダプタは他のアダプタを使用できません。
アダプタは <code>domain</code> パッケージや <code>appliacation</code> パッケージに配置した要素を使用しますが、それぞれのパッケージに配置した要素から <code>adapter</code> パッケージに配置した要素は使用できません</p>
</li>
</ul>
</div>
<div class="imageblock">
<div class="content">
<img src="onion-architecture-check.png" alt="onion architecture check" width="1108" height="762">
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ソースコードの断面slices"><a class="anchor" href="#_ソースコードの断面slices"></a>8.2. ソースコードの断面（Slices）</h3>
<div class="paragraph">
<p>Currently there are two "slice" rules offered by the Library API. These are basically rules
that slice the code by packages, and contain assertions on those slices. The entrance point is:</p>
</div>
<div class="paragraph">
<p>ライブラリ API は、今のところ「ソースコードの断面（slice）」について2種類の基本的なルールを提供しています。
パッケージに基づいて断面を生成するルールと、それぞれの断面に適用できるチェックからなるルールです。
入口は <code>SlicesRuleDefinition</code> です。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">com.tngtech.archunit.library.dependencies.SlicesRuleDefinition</code></pre>
</div>
</div>
<div class="paragraph">
<p>The API is based on the idea to sort classes into slices according to one or several package
infixes, and then write assertions against those slices. At the moment this is for example:</p>
</div>
<div class="paragraph">
<p>この API が元にしている考え方は、1つ以上のパッケージに配置したクラスをまとめて、共通するチェックを適用する、というものです。
例えば次のように記述できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">// sort classes by the first package after 'myapp'
// then check those slices for cyclic dependencies
SlicesRuleDefinition.slices().matching("..myapp.(*)..").should().beFreeOfCycles()

// checks all subpackages of 'myapp' for cycles
SlicesRuleDefinition.slices().matching("..myapp.(**)").should().notDependOnEachOther()

// sort classes by packages between 'myapp' and 'service'
// then check those slices for not having any dependencies on each other
SlicesRuleDefinition.slices().matching("..myapp.(**).service..").should().notDependOnEachOther()</code></pre>
</div>
</div>
<div class="paragraph">
<p>If this constraint is too rigid, e.g. in legacy applications where the package structure is rather
inconsistent, it is possible to further customize the slice creation. This can be done by specifying
a mapping of <code>JavaClass</code> to <code>SliceIdentifier</code> where classes with the same <code>SliceIdentifier</code> will
be sorted into the same slice. Consider this example:</p>
</div>
<div class="paragraph">
<p>パッケージ構造に一貫性のないレガシーアプリケーションのように、この制約が極めて柔軟性に欠けるとしたら、断面の作成自体を詳細化できます。
<code>JavaClass</code> に対応する <code>SliceIdentifier</code> を定義し、同じ <code>SliceIdentifier</code> を同じ断面へ格納させるのです。
具体的には次のように記述できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">SliceAssignment legacyPackageStructure = new SliceAssignment() {
    // this will specify which classes belong together in the same slice
    @Override
    public SliceIdentifier getIdentifierOf(JavaClass javaClass) {
        if (javaClass.getPackageName().startsWith("com.oldapp")) {
            return SliceIdentifier.of("Legacy");
        }
        if (javaClass.getName().contains(".esb.")) {
            return SliceIdentifier.of("ESB");
        }
        // ... further custom mappings

        // if the class does not match anything, we ignore it
        return SliceIdentifier.ignore();
    }

    // this will be part of the rule description if the test fails
    @Override
    public String getDescription() {
        return "legacy package structure";
    }
};

SlicesRuleDefinition.slices().assignedFrom(legacyPackageStructure).should().beFreeOfCycles()</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_循環参照の検出に関する設定configurations"><a class="anchor" href="#_循環参照の検出に関する設定configurations"></a>8.2.1. 循環参照の検出に関する設定（Configurations）</h4>
<div class="paragraph">
<p>There are two configuration parameters to adjust the behavior of the cycle detection.
They can be configured via <code>archunit.properties</code> (compare <a href="#_高度な設定advanced_configuration">Advanced Configuration</a>).</p>
</div>
<div class="paragraph">
<p>循環参照の検出に影響する2種類の設定パラメータがあります。
いずれも <code>archunit.properties</code> で設定できます。（<a href="#_高度な設定advanced_configuration">Advanced Configuration</a> を参照）</p>
</div>
<div class="listingblock">
<div class="title">archunit.properties</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs"># This will limit the maximum number of cycles to detect and thus required CPU and heap.
# default is 100
cycles.maxNumberToDetect=50

# This will limit the maximum number of dependencies to report per cycle edge.
# Note that ArchUnit will regardless always analyze all dependencies to detect cycles,
# so this purely affects how many dependencies will be printed in the report.
# Also note that this number will quickly affect the required heap since it scales with number.
# of edges and number of cycles
# default is 20
cycles.maxNumberOfDependenciesPerEdge=5</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_一般的なコーディングルールgeneral_coding_rules"><a class="anchor" href="#_一般的なコーディングルールgeneral_coding_rules"></a>8.3. 一般的なコーディングルール（General Coding Rules）</h3>
<div class="paragraph">
<p>The Library API also offers a small set of coding rules that might be useful in various projects.
Those can be found within</p>
</div>
<div class="paragraph">
<p>ライブラリ API は様々なプロジェクトで利用できるであろうコーディングルールを少しだけ提供しています。
<code>com.tngtech.archunit.library</code> パッケージを参照してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">com.tngtech.archunit.library</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_generalcodingrules"><a class="anchor" href="#_generalcodingrules"></a>8.3.1. GeneralCodingRules</h4>
<div class="paragraph">
<p>The class <code>GeneralCodingRules</code> contains a set of very general rules and conditions for coding.
For example:</p>
</div>
<div class="paragraph">
<p><code>GeneralCodingRules</code> クラスはコーディングに関する一般的なルールや条件式を含みます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>System.out</code> や <code>System.err</code> を使わずに、ロギング API を使用していることのチェック</p>
</li>
<li>
<p>汎用的な例外を送出せず、具体的な例外を送出していることのチェック</p>
</li>
<li>
<p><code>java.util.logging</code> を使わずに、Log4j や Logback や SLF4J などのライブラリを使用していることのチェック</p>
</li>
<li>
<p>フィールドインジェクションを使わずに、コンストラクタインジェクションを使用していることのチェック</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_dependencyrules"><a class="anchor" href="#_dependencyrules"></a>8.3.2. DependencyRules</h4>
<div class="paragraph">
<p>The class <code>DependencyRules</code> contains a set of rules and conditions for checking dependencies between classes.
For example:</p>
</div>
<div class="paragraph">
<p><code>DependencyRules</code> クラスはクラス間の依存関係に関するルールや条件式を含みます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To check that classes do not depend on classes from upper packages.</p>
</li>
<li>
<p>上位層のパッケージに配置したクラスに依存していないことのチェック</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_proxyrules"><a class="anchor" href="#_proxyrules"></a>8.3.3. ProxyRules</h4>
<div class="paragraph">
<p>The class <code>ProxyRules</code> contains a set of rules and conditions for checking the usage of proxy objects.
For example:</p>
</div>
<div class="paragraph">
<p><code>ProxyRules</code> クラスはプロキシオブジェクトの使い方に関するルールや条件式を含みます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>To check that methods that matches a predicate are not called directly from within the same class.</p>
</li>
<li>
<p>述語式にマッチするメソッドを、同じクラスから直接呼び出してしないことのチェック</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_plantuml_のコンポーネント図をルールとして扱うplantuml_component_diagrams_as_rules"><a class="anchor" href="#_plantuml_のコンポーネント図をルールとして扱うplantuml_component_diagrams_as_rules"></a>8.4. PlantUML のコンポーネント図をルールとして扱う（PlantUML Component Diagrams as rules）</h3>
<div class="paragraph">
<p>The Library API offers a feature that supports <a href="http://plantuml.com/component-diagram">PlantUML</a> diagrams.
This feature is located in</p>
</div>
<div class="paragraph">
<p>ライブラリ API は <a href="http://plantuml.com/component-diagram">PlantUML</a> の図を扱うことができます。
<code>com.tngtech.archunit.library.plantuml</code> パッケージを参照してください。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">com.tngtech.archunit.library.plantuml</code></pre>
</div>
</div>
<div class="paragraph">
<p>ArchUnit can derive rules straight from PlantUML diagrams and check to make sure that all imported
<code>JavaClasses</code> abide by the dependencies of the diagram. The respective rule can be created in the following way:</p>
</div>
<div class="paragraph">
<p>ArchUnit は PlantUML の図からルールを生成し、インポートした全ての <code>JavaClasses</code> が図に表現されている依存関係を満たしているかチェックできます。
次のように記述できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">URL myDiagram = getClass().getResource("my-diagram.puml");

classes().should(adhereToPlantUmlDiagram(myDiagram, consideringAllDependencies()));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Diagrams supported have to be component diagrams and associate classes to components via stereotypes.
The way this works is to use the respective package identifiers (compare
<code>ArchConditions.onlyHaveDependenciesInAnyPackage(..)</code>) as stereotypes:</p>
</div>
<div class="paragraph">
<p>対応している図の種類はコンポーネント図です。コンポーネントに関連するクラスはステレオタイプで表現します。
ステレオタイプはパッケージ識別子として機能することになります（<code>ArchConditions.onlyHaveDependenciesInAnyPackage(..)</code> を参照）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="simple-plantuml-archrule-example.png" alt="simple plantuml archrule example" width="173" height="210">
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">@startuml
[Some Source] &lt;&lt;..some.source..&gt;&gt;
[Some Target] &lt;&lt;..some.target..&gt;&gt; as target

[Some Source] --&gt; target
@enduml</code></pre>
</div>
</div>
<div class="paragraph">
<p>Consider this diagram applied as a rule via <code>adhereToPlantUmlDiagram(..)</code>, then for example
a class <code>some.target.Target</code> accessing <code>some.source.Source</code> would be reported as a violation.</p>
</div>
<div class="paragraph">
<p>この図を <code>adhereToPlantUmlDiagram(..)</code> へ適用して生成したルールは、<code>some.target.Target</code> クラスから <code>some.source.Source</code> クラスへのアクセスを発見すると、違反として報告するようになります。</p>
</div>
<div class="sect3">
<h4 id="_plantuml_に関する設定configurations"><a class="anchor" href="#_plantuml_に関する設定configurations"></a>8.4.1. PlantUML に関する設定（Configurations）</h4>
<div class="paragraph">
<p>There are different ways to deal with dependencies of imported classes not covered by the
diagram at all. The behavior of the PlantUML API can be configured by supplying a respective
<code>Configuration</code>:</p>
</div>
<div class="paragraph">
<p>PlantUML の図に表現されていないクラスの依存関係を扱う方法はいろいろあります。
PlantUML API の振る舞いは <code>Configuration</code> を指定して制御できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">// considers all dependencies possible (including java.lang, java.util, ...)
classes().should(adhereToPlantUmlDiagram(
        mydiagram, consideringAllDependencies()))

// considers only dependencies specified in the PlantUML diagram
// (so any unknown dependency will be ignored)
classes().should(adhereToPlantUmlDiagram(
        mydiagram, consideringOnlyDependenciesInDiagram()))

// considers only dependencies in any specified package
// (control the set of dependencies to consider, e.g. only com.myapp..)
classes().should(adhereToPlantUmlDiagram(
        mydiagram, consideringOnlyDependenciesInAnyPackage("..some.package..")))</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to further customize which dependencies to ignore:</p>
</div>
<div class="paragraph">
<p>無視する依存関係を詳しく指定できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">// there are further ignore flavors available
classes().should(adhereToPlantUmlDiagram(mydiagram).ignoreDependencies(predicate))</code></pre>
</div>
</div>
<div class="paragraph">
<p>A PlantUML diagram used with ArchUnit must abide by a certain set of rules:</p>
</div>
<div class="paragraph">
<p>ArchUnit から使用する PlantUML の図は、次のようなルールに従わなければなりません。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>コンポーネントは角括弧形式で表記しなければなりません（<code>[Some Component]</code>）</p>
</li>
<li>
<p>コンポーネントには1つ以上（複数も可）のステレオタイプが必要です。図中のステレオタイプ名は一意で、適切なパッケージ識別子でなければなりません（例えば <code>&lt;&lt;..example..&gt;&gt;</code>。<code>..</code> は任意のパッケージ階層を表す。詳しくは <a href="#_コア_apithe_core_api">The Core API</a> を参照）</p>
</li>
<li>
<p>コンポーネントには別名を指定できます（<code>[Some Component] &lt;&lt;..example..&gt;&gt; as myalias</code>）。別名に使用できるのは英数字のみで、クォートで囲んではいけません</p>
</li>
<li>
<p>コンポーネントには色を指定できます（<code>[Some Component] &lt;&lt;..example..&gt;&gt; \#OrangeRed</code>）</p>
</li>
<li>
<p>依存関係を表す線分に使えるのは矢印付きの破線だけです（<code>--&gt;</code>）</p>
</li>
<li>
<p>依存関係を表す線分の方向は左から右（<code>--&gt;</code>）、あるいは、右から左のみです（<code>&lt;--</code>）</p>
</li>
<li>
<p>依存関係を表す線分には任意の数の破線を使えます（<code>-&gt;</code> や <code>-----&gt;</code>）</p>
</li>
<li>
<p>依存関係を表す線分には方向を示すヒントを指定したり（<code>-up-&gt;</code>）、色を指定できます（<code>-[\#green]-&gt;</code>）</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>You can compare this
<a href="https://github.com/TNG/ArchUnit-Examples/blob/main/example-plain/src/test/resources/com/tngtech/archunit/exampletest/shopping_example.puml">diagram of ArchUnit-Examples</a>.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/TNG/ArchUnit-Examples/blob/main/example-plain/src/test/resources/com/tngtech/archunit/exampletest/shopping_example.puml">diagram of ArchUnit-Examples</a> の図を参照してみてください。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_アーキテクチャルール違反の永続化freezing_arch_rules"><a class="anchor" href="#_アーキテクチャルール違反の永続化freezing_arch_rules"></a>8.5. アーキテクチャルール違反の永続化（Freezing Arch Rules）</h3>
<div class="paragraph">
<p>When rules are introduced in grown projects, there are often hundreds or even thousands of violations,
way too many to fix immediately. The only way to tackle such extensive violations is to establish an
iterative approach, which prevents the code base from further deterioration.</p>
</div>
<div class="paragraph">
<p>発展中のプロジェクトにルールを導入すると、数百どころか数千の違反を検出してしまい、とてもすぐに修正できない状態になる場合があります。
大量に違反が発生している状況を解決するには、さらに悪化するのを防ぐため反復的なアプローチを確立するしかありません。</p>
</div>
<div class="paragraph">
<p><code>FreezingArchRule</code> can help in these scenarios by recording all existing violations to a <code>ViolationStore</code>.
Consecutive runs will then only report new violations and ignore known violations.
If violations are fixed, <code>FreezingArchRule</code> will automatically reduce the known stored violations to prevent any regression.</p>
</div>
<div class="paragraph">
<p>そういう場合に役立つのが <code>FreezingArchRule</code> です。
<code>FreezingArchRule</code> は検出済みの全ての違反を <code>ViolationStore</code> へ記録します。
そうすると、一度記録した違反は無視して、新たに検出した違反だけを報告するようになります。
記録済みの違反を修正すると、<code>FreezingArchRule</code> はリグレッションを防ぐため自動的に記録済みの違反を削除します。</p>
</div>
<div class="sect3">
<h4 id="_使い方usage"><a class="anchor" href="#_使い方usage"></a>8.5.1. 使い方（Usage）</h4>
<div class="paragraph">
<p>To freeze an arbitrary <code>ArchRule</code> just wrap it into a <code>FreezingArchRule</code>:</p>
</div>
<div class="paragraph">
<p>使い方は、永続化したい任意の <code>ArchRule</code> を <code>FreezingArchRule</code> で包み込むだけです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">ArchRule rule = FreezingArchRule.freeze(classes().should()./*complete ArchRule*/);</code></pre>
</div>
</div>
<div class="paragraph">
<p>On the first run all violations of that rule will be stored as the current state. On consecutive runs only
new violations will be reported. By default <code>FreezingArchRule</code> will ignore line numbers, i.e. if a
violation is just shifted to a different line, it will still count as previously recorded
and will not be reported.</p>
</div>
<div class="paragraph">
<p>導入してから始めて実行したテストで検出した違反は、最新の状態として記録されます。
その後は、新しく検出した違反だけを報告するようになります。
初期設定では <code>FreezingArchRule</code> は行番号を無視します。
つまり、違反した箇所が数行移動しただけでも、最初に記録した違反と同じ違反として認識し、報告しないということです。</p>
</div>
</div>
<div class="sect3">
<h4 id="_設定configuration"><a class="anchor" href="#_設定configuration"></a>8.5.2. 設定（Configuration）</h4>
<div class="paragraph">
<p>By default <code>FreezingArchRule</code> will use a simple <code>ViolationStore</code> based on plain text files.
This is sufficient to add these files to any version control system to continuously track the progress.
You can configure the location of the violation store within <code>archunit.properties</code> (compare <a href="#_高度な設定advanced_configuration">Advanced Configuration</a>):</p>
</div>
<div class="paragraph">
<p>初期設定の <code>FreezingArchRule</code> は平文テキストファイルを使用する単純な <code>ViolationStore</code> を使うようになっています。
継続的に状況を追跡するなら、テキストファイルをバージョン管理システムへ登録するだけで十分でしょう。
違反記録ファイルの場所は <code>archunit.properties</code> で指定できます（<a href="#_高度な設定advanced_configuration">Advanced Configuration</a> を参照）。</p>
</div>
<div class="listingblock">
<div class="title">archunit.properties</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">freeze.store.default.path=/some/path/in/a/vcs/repo</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore, it is possible to configure</p>
</div>
<div class="paragraph">
<p>他にも次のような設定項目があります。</p>
</div>
<div class="listingblock">
<div class="title">archunit.properties</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs"># must be set to true to allow the creation of a new violation store
# default is false
freeze.store.default.allowStoreCreation=true

# can be set to false to forbid updates of the violations stored for frozen rules
# default is true
freeze.store.default.allowStoreUpdate=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>This can help in CI environments to prevent misconfiguration:
For example, a CI build should probably never create a new the violation store, but operate on
an existing one.</p>
</div>
<div class="paragraph">
<p>これらの設定項目は CI 環境で実行するときの設定誤りを予防するために役立ちます。
具体的には、CI環境で実行するビルドは新しい違反記録ファイルを作るべきではないし、既存のファイルがあるならそれを参照するべきなのです。</p>
</div>
<div class="paragraph">
<p>As mentioned in <a href="#_設定の上書きoverriding_configuration">Overriding configuration</a>, these properties can be passed as system properties as needed.
For example to allow the creation of the violation store in a specific environment, it is possible to pass the system property via</p>
</div>
<div class="paragraph">
<p><a href="#_設定の上書きoverriding_configuration">Overriding configuration</a> で説明したように、これらの設定項目は必要ならシステムプロパティとして指定できるようになっています。
例えば、任意の環境で違反記録ファイルを作成させたいときは、次のようなシステムプロパティを指定すればいいでしょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">-Darchunit.freeze.store.default.allowStoreCreation=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to allow all violations to be "refrozen", i.e. the store will just be updated
with the current state, and the reported result will be success. Thus, it is effectively the same behavior
as if all rules would never have been frozen.
This can e.g. make sense, because current violations are consciously accepted and should be added to the store,
or because the format of some violations has changed. The respective property to allow refreezing
all current violations is <code>freeze.refreeze=true</code>, where the default is <code>false</code>.</p>
</div>
<div class="paragraph">
<p>全ての違反を「再凍結（refrozen）」させることも可能です。
そうすると、違反記録ファイルを最新の状態へ更新し、実行結果は成功として終了します。
実質的に全てのルールを永続化していないときの振る舞いと同じになります。
これに意味があるのは、今の違反状況を認識し、受け入れており、違反記録ファイルへ追加してもよいと考えている場合だけです。
前から存在していた違反の形式が変化しているのかもしれません。
今の違反状態を再凍結させるにはシステムプロパティ <code>freez.refreeze=true</code> を指定します。初期値は <code>false</code> です。</p>
</div>
</div>
<div class="sect3">
<h4 id="_拡張可能な部分についてextension"><a class="anchor" href="#_拡張可能な部分についてextension"></a>8.5.3. 拡張可能な部分について（Extension）</h4>
<div class="paragraph">
<p><code>FreezingArchRule</code> provides two extension points to adjust the behavior to custom needs.
The first one is the <code>ViolationStore</code>, i.e. the store violations will be recorded to. The second one
is the <code>ViolationLineMatcher</code>, i.e. how <code>FreezingArchRule</code> will associate lines of stored violations
with lines of actual violations. As mentioned, by default this is a line matcher that ignores the
line numbers of violations within the same class.</p>
</div>
<div class="paragraph">
<p><code>FreezingArchRule</code> には拡張可能な部分が2か所あり、振る舞いを調整するのに使用できます。
1つ目は <code>ViolationStore</code> で、違反の情報をどこに記録するのか制御します。
2つ目は <code>ViolationLineMatcher</code> で、<code>FreezingArchRule</code> が違反を記録するとき、行番号を含めるかどうかを制御します。
前述したとおり、初期設定では行番号を記録しないようになっています。</p>
</div>
<div class="sect4">
<h5 id="_違反記録ストアviolation_store"><a class="anchor" href="#_違反記録ストアviolation_store"></a>違反記録ストア（Violation Store）</h5>
<div class="paragraph">
<p>As mentioned in <a href="#_設定configuration">Configuration</a>, the default <code>ViolationStore</code> is a simple text based store.
It can be exchanged though, for example to store violations in a database.
To provide your own implementation, implement <code>com.tngtech.archunit.library.freeze.ViolationStore</code> and
configure <code>FreezingArchRule</code> to use it. This can either be done programmatically:</p>
</div>
<div class="paragraph">
<p><a href="#_設定configuration">Configuration</a> で説明したとおり、初期設定の <code>ViolationStore</code> は単純に平文テキストファイルへ記録するようになっています。
ファイルではなく、データベースへ記録させることができるということです。
自分で実装するなら、<code>com.thgtech.archunit.library.freeze.ViolationStore</code> インターフェイスを実装したクラスを <code>FreezingArchRule</code> に指定すればいいでしょう。
次のようにプログラムで記述できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">FreezingArchRule.freeze(rule).persistIn(customViolationStore);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively it can be configured via <code>archunit.properties</code> (compare <a href="#_高度な設定advanced_configuration">Advanced Configuration</a>):</p>
</div>
<div class="paragraph">
<p>あるいは、次のように <code>archunit.properties</code> の設定項目にも記述できます（<a href="#_高度な設定advanced_configuration">Advanced Configuration</a> を参照）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">freeze.store=fully.qualified.name.of.MyCustomViolationStore</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can supply properties to initialize the store by using the namespace <code>freeze.store</code>.
For properties</p>
</div>
<div class="paragraph">
<p>名前空間 <code>freeze.store</code> に、違反記録ストアを初期化するためのプロパティを指定できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">freeze.store.propOne=valueOne
freeze.store.propTwo=valueTwo</code></pre>
</div>
</div>
<div class="paragraph">
<p>the method <code>ViolationStore.initialize(props)</code> will be called with the properties</p>
</div>
<div class="paragraph">
<p>これらのプロパティは <code>VilationStore.initialize(props)</code> の引数に指定されます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">propOne=valueOne
propTwo=valueTwo</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_違反行マッチャーviolation_line_matcher"><a class="anchor" href="#_違反行マッチャーviolation_line_matcher"></a>違反行マッチャー（Violation Line Matcher）</h5>
<div class="paragraph">
<p>The <code>ViolationLineMatcher</code> compares lines from occurred violations with lines from the store.
The default implementation ignores line numbers and numbers of anonymous classes or lambda expressions,
and counts lines as equivalent when all other details match.
A custom <code>ViolationLineMatcher</code> can again either be defined programmatically:</p>
</div>
<div class="paragraph">
<p><code>VilationLineMatcher</code> は違反と、違反の発生した行番号を、違反記録ストアと照合します。
既定の実装では、行番号と、無名クラスやラムダ式の数を無視して、全体の行数が一致すればそれ以外の全ての詳細も一致したものと見做すようになっています。
独自の <code>ViolationLineMatcher</code> があるときは、次のようにプログラムで記述できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">FreezingArchRule.freeze(rule).associateViolationLinesVia(customLineMatcher);</code></pre>
</div>
</div>
<div class="paragraph">
<p>or via <code>archunit.properties</code>:</p>
</div>
<div class="paragraph">
<p>あるいは、次のように <code>archunit.properties</code> の設定項目にも記述できます（<a href="#_高度な設定advanced_configuration">Advanced Configuration</a> を参照）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">freeze.lineMatcher=fully.qualified.name.of.MyCustomLineMatcher</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ソフトウェアアーキテクチャのメトリクスsoftware_architecture_metrics"><a class="anchor" href="#_ソフトウェアアーキテクチャのメトリクスsoftware_architecture_metrics"></a>8.6. ソフトウェアアーキテクチャのメトリクス（Software Architecture Metrics）</h3>
<div class="paragraph">
<p>Similar to code quality metrics, like cyclomatic complexity or method length,
software architecture metrics strive to measure the structure and design of software.
ArchUnit can be used to calculate some well-known software architecture metrics.
The foundation of these metrics is generally some form of componentization, i.e.
we partition the classes/methods/fields of a Java application into related units
and provide measurements for these units. In ArchUnit this concept is expressed by
<code>com.tngtech.archunit.library.metrics.MetricsComponent</code>. For some metrics, like the
Cumulative Dependency Metrics by John Lakos, we also need to know the dependencies
between those components, which are naturally derived from the dependencies between
the elements (e.g. classes) within these components.</p>
</div>
<div class="paragraph">
<p>ソースコード品質のメトリクスにおけるサイクロマティック複雑度やメソッド長のように、ソフトウェアアーキテクチャのメトリクスとして、ソフトウェアの設計や構造を計測する試みが続けられています。
ArchUnit は既知のソフトウェアアーキテクチャメトリクスの一部を算出できるようになっています。
メトリクスの根拠になるのは、基本的になんらかの形でコンポーネント化に貢献する要素です。
例えば、私たちは Java アプリケーションをクラス、メソッド、フィールドなどの単位に分割し、それぞれの単位がどれだけあるのか計測します。
ArchUnit ではこの考え方を <code>com.tngtech.archunit.library.metrics.MetricsCOmponent</code> として表現しています。
ジョン・レイコスの提案した「累積依存性メトリクス（Cumulative Dependency Metrics）」のように、一部のメトリクスでは、コンポーネント間の依存関係に関する情報が必要になります。
これは、コンポーネントに含まれる全ての要素（クラスなど）に関する依存関係から導出できます。</p>
</div>
<div class="paragraph">
<p>A very simple concrete example would be to consider some Java packages as
components and the classes within these packages as the contained elements. From
the dependencies between the classes we can derive which package depends on which
other package.</p>
</div>
<div class="paragraph">
<p>簡単な具体例を考えると、Java パッケージをコンポーネントとした場合、コンポーネントの構成要素はクラスになります。
従って、全てのクラスの依存関係が分かれば、そのパッケージが他のパッケージにどれだけ依存しているのか導出できるのです。</p>
</div>
<div class="paragraph">
<p>The following will give a quick overview of the metrics that ArchUnit can calculate.
However, for further background information it is recommended to rely on
some dedicated literature that explains these metrics in full detail.</p>
</div>
<div class="paragraph">
<p>ArchUnit で計算できるメトリクスの例は次のとおりです。
それぞれのメトリクスに関する正確な説明が必要なときは、出典の文献を参照してください。</p>
</div>
<div class="sect3">
<h4 id="_ジョンレイコスの提案した累積依存性メトリクスcumulative_dependency_metrics_by_john_lakos"><a class="anchor" href="#_ジョンレイコスの提案した累積依存性メトリクスcumulative_dependency_metrics_by_john_lakos"></a>8.6.1. ジョン・レイコスの提案した「累積依存性メトリクス」（Cumulative Dependency Metrics by John Lakos）</h4>
<div class="paragraph">
<p>These are software architecture metrics as defined by John Lakos in his book
"Large-Scale C++ Software Design". The basic idea is to calculate the <code>DependsOn</code>
value for each component, which is the sum of all components that can be
transitively reached from some component including the component itself.</p>
</div>
<div class="paragraph">
<p>From these values we can derive</p>
</div>
<div class="paragraph">
<p>これは、ジョン・レイコスが「Large-Scale C++ Software Design」でソフトウェアアーキテクチャのメトリクスです。
それぞれのコンポーネントについて <code>DependsOn</code> を集計するのが基本的な考え方です。
末端のコンポーネントそれ自体を含むコンポーネントの一部から、推移的に到達可能なコンポーネントの依存関係の総和を、全てのコンポーネントの依存関係の総和と見做す考え方です。</p>
</div>
<div class="paragraph">
<p>次のような指標を導出できます。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>CCD</strong> - 累積コンポーネント依存性:
全てのコンポーネントに関する <code>DependsOn</code> の総和。</p>
</li>
<li>
<p><strong>ACD</strong> - 平均コンポーネント依存性:
<code>CCD</code> を全てのコンポーネント数で除算した値。</p>
</li>
<li>
<p><strong>RACD</strong> - 相対平均コンポーネント依存性:
<code>ACD</code> を全てのコンポーネント数で除算した値。</p>
</li>
<li>
<p><strong>NACD</strong> - 正規化平均コンポーネント依存性:
システムの <code>CCD</code> を、同じ数のコンポーネントからなる平衡二分木の <code>CCD</code> で除算した値。</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_具体例example"><a class="anchor" href="#_具体例example"></a>具体例（Example）</h5>
<div class="imageblock">
<div class="content">
<img src="lakos-example.png" alt="lakos example" width="445" height="567">
</div>
</div>
<div class="paragraph">
<p>Thus these metrics provide some insights into the complexity of the dependency graph of a system.
Note that in a cycle all elements have the same <code>DependsOn</code> value which will lead to an increased
CCD. In fact for any non-trivial (<code>n &gt;= 5</code>) acyclic graph of components the RACD is bound by <code>0.6</code>.</p>
</div>
<div class="paragraph">
<p>これらのメトリクスは、システムの依存関係グラフの複雑さに関する洞察をもたらします。
巡回グラフの全ての要素の <code>DependsOn</code> が同じ値になると、CCD は増加するので注意が必要です。
実際には、任意の自明でない非巡回グラフ（<code>n &gt;= 5</code>）では、RACD の上限値は <code>0.6</code> になります。</p>
</div>
</div>
<div class="sect4">
<h5 id="_api_の使い方how_to_use_the_api"><a class="anchor" href="#_api_の使い方how_to_use_the_api"></a>API の使い方（How to use the API）</h5>
<div class="paragraph">
<p>The values described for these metrics can be calculated in the following way:</p>
</div>
<div class="paragraph">
<p>それぞれのメトリクスは次のように算出できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">import com.tngtech.archunit.library.metrics.ArchitectureMetrics;
// ...

JavaClasses classes = // ...
Set&lt;JavaPackage&gt; packages = classes.getPackage("com.example").getSubpackages();

// These components can also be created in a package agnostic way, compare MetricsComponents.from(..)
MetricsComponents&lt;JavaClass&gt; components = MetricsComponents.fromPackages(packages);

LakosMetrics metrics = ArchitectureMetrics.lakosMetrics(components);

System.out.println("CCD: " + metrics.getCumulativeComponentDependency());
System.out.println("ACD: " + metrics.getAverageComponentDependency());
System.out.println("RACD: " + metrics.getRelativeAverageComponentDependency());
System.out.println("NCCD: " + metrics.getNormalizedCumulativeComponentDependency());</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ロバートcマーチンの提案したコンポーネント依存性メトリクスcomponent_dependency_metrics_by_robert_c_martin"><a class="anchor" href="#_ロバートcマーチンの提案したコンポーネント依存性メトリクスcomponent_dependency_metrics_by_robert_c_martin"></a>8.6.2. ロバート・C・マーチンの提案したコンポーネント依存性メトリクス（Component Dependency Metrics by Robert C. Martin）</h4>
<div class="paragraph">
<p>These software architecture metrics were defined by Robert C. Martin in various sources,
for example in his book "Clean architecture : a craftsman&#8217;s guide to software structure and design".</p>
</div>
<div class="paragraph">
<p>ロバート・C・マーチンはさまざまなソフトウェアアーキテクチャのメトリクスをいろんなところで紹介しています。
例えば「Clean archtecture : a craftsman&#8217;s guide to software structure and design」など。</p>
</div>
<div class="paragraph">
<p>The foundation are again components, that must in this case contain classes as their elements
(i.e. these are purely object-oriented metrics that need a concept of abstract classes).</p>
</div>
<div class="paragraph">
<p>The metrics are based on the following definitions:</p>
</div>
<div class="paragraph">
<p>対象はやはりコンポーネントで、構成要素としてクラスを持っていることになっています（ここで紹介するメトリクスは、抽象クラスの考え方が必須の純粋なオブジェクト指向ソフトウェアのメトリクスです）。</p>
</div>
<div class="paragraph">
<p>それぞれのメトリクスは次のような定義に基づいています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>外向きの結合（Efferent Coupling）（<strong>Ce</strong>）: 他のコンポーネントへ向かう外向きの依存関係の総数</p>
</li>
<li>
<p>内向きの結合（Afferent Coupling）（<strong>Ca</strong>）: 他のコンポーネントから向かってくる内向きの依存関係の総数</p>
</li>
<li>
<p>不安定性（Instability）（<strong>I</strong>）: <code>Ce / (Ca + Ce)</code> 全ての依存関係に対する外向きの依存関係の割合</p>
</li>
<li>
<p>抽象度（Abstractness）（<strong>A</strong>）: <code>num(抽象クラス) / num(全てのクラス)</code> コンポーネント中の全てのクラスに対する抽象クラスの割合</p>
</li>
<li>
<p>主系列からの距離（Distance from Main Sequence）（<strong>D</strong>）: <code>| A + I - 1 |</code> 理想直線 <code>(A=1, I=0)</code> と <code>(A=0, I=1)</code> からの正規化した距離</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Note that ArchUnit slightly differs from the original definition. In ArchUnit
the Abstractness value is only based on public classes, i.e.
classes that are visible from the outside. The reason is that <strong>Ce</strong>, <strong>Ca</strong> and <strong>I</strong> all
are metrics with respect to coupling of components. But only classes that are visible
to the outside can affect coupling between components,
so it makes sense to only consider those classes to calculate the <strong>A</strong> value.</p>
</div>
<div class="paragraph">
<p>ArchUnit の実装は本来の定義とはやや異なる内容になっているので注意してください。
ArchUnit では、抽象度を算出するのに、public クラス（つまり外部から参照できるクラス）だけを集計しています。
抽象度以外の全てのメトリクスはコンポーネント間の結合に関するメトリクスなので、コンポーネント間の結合に寄与するクラスだけを対象にするほうが適切だと考えたからです。</p>
</div>
<div class="sect4">
<h5 id="_具体例example_2"><a class="anchor" href="#_具体例example_2"></a>具体例（Example）</h5>
<div class="paragraph">
<p>The following provides some example where the <code>A</code> values assume some random factor
of abstract classes within the respective component.</p>
</div>
<div class="paragraph">
<p>次の例では、コンポーネント中にランダムな数の抽象クラスが存在するものとして、抽象度 <code>A</code> を算出しています。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="martin-example.png" alt="martin example" width="445" height="743">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_api_の使い方how_to_use_the_api_2"><a class="anchor" href="#_api_の使い方how_to_use_the_api_2"></a>API の使い方（How to use the API）</h5>
<div class="paragraph">
<p>The values described for these metrics can be calculated in the following way:</p>
</div>
<div class="paragraph">
<p>それぞれのメトリクスは次のように算出できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">import com.tngtech.archunit.library.metrics.ArchitectureMetrics;
// ...

JavaClasses classes = // ...
Set&lt;JavaPackage&gt; packages = classes.getPackage("com.example").getSubpackages();

// These components can also be created in a package agnostic way, compare MetricsComponents.from(..)
MetricsComponents&lt;JavaClass&gt; components = MetricsComponents.fromPackages(packages);

ComponentDependencyMetrics metrics = ArchitectureMetrics.componentDependencyMetrics(components);

System.out.println("Ce: " + metrics.getEfferentCoupling("com.example.component"));
System.out.println("Ca: " + metrics.getAfferentCoupling("com.example.component"));
System.out.println("I: " + metrics.getInstability("com.example.component"));
System.out.println("A: " + metrics.getAbstractness("com.example.component"));
System.out.println("D: " + metrics.getNormalizedDistanceFromMainSequence("com.example.component"));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ハーバートドワリルの提案した可視性メトリクスvisibility_metrics_by_herbert_dowalil"><a class="anchor" href="#_ハーバートドワリルの提案した可視性メトリクスvisibility_metrics_by_herbert_dowalil"></a>8.6.3. ハーバート・ドワリルの提案した可視性メトリクス（Visibility Metrics by Herbert Dowalil）</h4>
<div class="paragraph">
<p>These software architecture metrics were defined by Herbert Dowalil in his book
"Modulare Softwarearchitektur: Nachhaltiger Entwurf durch Microservices, Modulithen und SOA 2.0".
They provide a measure for the Information Hiding Principle, i.e. the relation of visible to hidden
elements within a component.</p>
</div>
<div class="paragraph">
<p>The metrics are composed from the following definitions:</p>
</div>
<div class="paragraph">
<p>これらのソフトウェアアーキテクチャのメトリクスは、ハーバート・ドワリルが「Modulare Softwarearchitektur: Nachhaltiger Entwurf durch Microservices, Modulithen und SOA 2.0」で提案したものです。
情報隠蔽の原則に基づく指標として、コンポーネント中の可視要素から不可視要素への関連などを提供します。</p>
</div>
<div class="paragraph">
<p>それぞれのメトリクスは次のような定義に基づいています。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>相対可視性（<strong>RV</strong>）: <code>num(可視要素) / num(全ての要素)</code> それぞれのコンポーネントについて計算します</p>
</li>
<li>
<p>平均相対可視性（<strong>ARV</strong>）: 全てのコンポーネントに関する <strong>RV</strong> の平均値</p>
</li>
<li>
<p>全体相対可視性（<strong>GRV</strong>）: <code>num(可視要素) / num(全ての要素)</code> 全てのコンポーネントについて計算します</p>
</li>
</ul>
</div>
<div class="sect4">
<h5 id="_具体例example_3"><a class="anchor" href="#_具体例example_3"></a>具体例（Example）</h5>
<div class="imageblock">
<div class="content">
<img src="dowalil-example.png" alt="dowalil example" width="685" height="326">
</div>
</div>
</div>
<div class="sect4">
<h5 id="_api_の使い方how_to_use_the_api_3"><a class="anchor" href="#_api_の使い方how_to_use_the_api_3"></a>API の使い方（How to use the API）</h5>
<div class="paragraph">
<p>The values described for these metrics can be calculated in the following way:</p>
</div>
<div class="paragraph">
<p>それぞれのメトリクスは次のように算出できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">import com.tngtech.archunit.library.metrics.ArchitectureMetrics;
// ...

JavaClasses classes = // ...
Set&lt;JavaPackage&gt; packages = classes.getPackage("com.example").getSubpackages();

// These components can also be created in a package agnostic way, compare MetricsComponents.from(..)
MetricsComponents&lt;JavaClass&gt; components = MetricsComponents.fromPackages(packages);

VisibilityMetrics metrics = ArchitectureMetrics.visibilityMetrics(components);

System.out.println("RV : " + metrics.getRelativeVisibility("com.example.component"));
System.out.println("ARV: " + metrics.getAverageRelativeVisibility());
System.out.println("GRV: " + metrics.getGlobalRelativeVisibility());</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_junit_拡張機能junit_support"><a class="anchor" href="#_junit_拡張機能junit_support"></a>9. JUnit 拡張機能（JUnit Support）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>At the moment ArchUnit offers extended support for writing tests with JUnit 4 and JUnit 5.
This mainly tackles the problem of caching classes between test runs and to remove some boilerplate.</p>
</div>
<div class="paragraph">
<p>Consider a straight forward approach to write tests:</p>
</div>
<div class="paragraph">
<p>現時点の ArchUnit は、JUnit 4 と JUnit 5 でテストを書きやすくするための機能を提供しています。
主な目的は、実行するテストの間でクラスをキャッシュする仕組みを提供し、典型的な準備コードを不要にすることです。</p>
</div>
<div class="paragraph">
<p>まず、単純なテストを書く方法について検討してみましょう。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@Test
public void rule1() {
    JavaClasses importedClasses = new ClassFileImporter().importClasspath();

    ArchRule rule = classes()...

    rule.check(importedClasses);
}

@Test
public void rule2() {
    JavaClasses importedClasses = new ClassFileImporter().importClasspath();

    ArchRule rule = classes()...

    rule.check(importedClasses);
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For bigger projects, this will have a significant performance impact, since the import can take
a noticeable amount of time. Also rules will always be checked against the imported classes, thus
the explicit call of <code>check(importedClasses)</code> is bloat and error prone (i.e. it can be forgotten).</p>
</div>
<div class="paragraph">
<p>プロジェクトが大きくなってくると、このテストはクラスのインポートが完了するまでの時間がとても長くなってしまいます。
また、ルールはインポートした全てのクラスをチェックするため、<code>check(importedClasses)</code> の呼び出しは多数のクラスをチェックすることになり、間違いを見逃しやすくなってしまいます（あるいは忘れやすくなってしまいます）。</p>
</div>
<div class="sect2">
<h3 id="_junit_4_および_junit_5_への対応junit_4_5_support"><a class="anchor" href="#_junit_4_および_junit_5_への対応junit_4_5_support"></a>9.1. JUnit 4 および JUnit 5 への対応（JUnit 4 &amp; 5 Support）</h3>
<div class="paragraph">
<p>Make sure you follow the installation instructions at <a href="#_インストールinstallation">Installation</a>, in particular to include
the correct dependency for the respective JUnit support.</p>
</div>
<div class="paragraph">
<p><a href="#_インストールinstallation">Installation</a> に記載したインストールの手順に従い、JUnit のバージョンに合わせて適切な依存ライブラリを追加してください。</p>
</div>
<div class="sect3">
<h4 id="_テストを書くwriting_tests"><a class="anchor" href="#_テストを書くwriting_tests"></a>9.1.1. テストを書く（Writing tests）</h4>
<div class="paragraph">
<p>Tests look and behave very similar between JUnit 4 and 5. The only difference is, that with JUnit 4
it is necessary to add a specific <code>Runner</code> to take care of caching and checking rules, while JUnit 5
picks up the respective <code>TestEngine</code> transparently. A test typically looks the following way:</p>
</div>
<div class="paragraph">
<p>JUnit 4 と JUnit 5 のテストは見た目も振る舞いも非常によく似ています。
違いは、JUnit 4 でキャッシュやルールをチェックする仕組みを有効にするには、特定の <code>Runner</code> を指定しなければならないところです。
JUnit 5 なら適切な <code>TestEngine</code> を透過的に選択するだけです。
いずれにしてもテストは次のような形式になります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@RunWith(ArchUnitRunner.class) // Remove this line for JUnit 5!!
@AnalyzeClasses(packages = "com.myapp")
public class ArchitectureTest {

    // ArchRules can just be declared as static fields and will be evaluated
    @ArchTest
    public static final ArchRule rule1 = classes().should()...

    @ArchTest
    public static final ArchRule rule2 = classes().should()...

    @ArchTest
    public static void rule3(JavaClasses classes) {
        // The runner also understands static methods with a single JavaClasses argument
        // reusing the cached classes
    }

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>JavaClass</code> cache will work in two ways. On the one hand it will cache the classes by test,
so they can be reused by several rules declared within the same class. On the other hand, it
will cache the classes by location, so a second test that wants to import classes from the same
URLs will reuse the classes previously imported as well. Note that this second caching uses
soft references, so the classes will be dropped from memory, if the heap runs low.
For further information see <a href="#_キャッシュの制御controlling_the_cache">Controlling the Cache</a>.</p>
</div>
<div class="paragraph">
<p><code>JavaClass</code> のキャッシュは2種類の場面で仕事します。
1つ目は、テストメソッドで扱っているクラスをキャッシュすることです。
同じテストクラスにフィールドとして定義したいくつものルールで再利用できるのです。
2つ目は、位置に対応するクラスをキャッシュすることです。
同じURLからインポートする2つ目のテストでは、前にインポートしたクラスを再利用できるのです。
ただし、このキャッシュはソフト参照を利用しているため、クラスがヒープメモリから追い出されると無効になってしまいます。
より詳しく知りたければ <a href="#_キャッシュの制御controlling_the_cache">Controlling the Cache</a> を参照してください。</p>
</div>
</div>
<div class="sect3">
<h4 id="_インポートの制御controlling_the_import"><a class="anchor" href="#_インポートの制御controlling_the_import"></a>9.1.2. インポートの制御（Controlling the Import）</h4>
<div class="paragraph">
<p>Which classes will be imported can be controlled in a declarative way through <code>@AnalyzeClasses</code>.
If no packages or locations are provided, the whole classpath will be imported.
You can specify packages to import as strings:</p>
</div>
<div class="paragraph">
<p>インポートするクラスは <code>@AnalyzeClasses</code> により宣言的に指定できるようになっています。
パッケージや位置を指定しなかった場合、クラスパス上の全てのクラスがインポートされることになります。
パッケージは文字列で指定できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@AnalyzeClasses(packages = {"com.myapp.subone", "com.myapp.subtwo"})</code></pre>
</div>
</div>
<div class="paragraph">
<p>To better support refactorings, packages can also be declared relative to classes, i.e. the
packages these classes reside in will be imported:</p>
</div>
<div class="paragraph">
<p>リファクタリングを楽にするため、パッケージを指定するときはクラスに対する相対的な要素として指定するといいでしょう。
次のようにクラスを指定すると、クラスの所属するパッケージと、そのサブパッケージをインポートするようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@AnalyzeClasses(packagesOf = {SubOneConfiguration.class, SubTwoConfiguration.class})</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a third option, locations can be specified freely by implementing a <code>LocationProvider</code>:</p>
</div>
<div class="paragraph">
<p>もう1つの選択肢は、<code>LocationProvider</code> を実装して位置を自由に制御することです。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">public class MyLocationProvider implements LocationProvider {
    @Override
    public Set&lt;Location&gt; get(Class&lt;?&gt; testClass) {
        // Determine Locations (= URLs) to import
        // Can also consider the actual test class, e.g. to read some custom annotation
    }
}

@AnalyzeClasses(locations = MyLocationProvider.class)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Furthermore to choose specific classes beneath those locations, <code>ImportOptions</code> can be
specified (compare <a href="#_コア_apithe_core_api">The Core API</a>). For example, to import the classpath, but only consider
production code, and only consider code that is directly supplied and does not come from JARs:</p>
</div>
<div class="paragraph">
<p>また、位置を指定しつつクラスも指定したければ <code>ImportOptions</code> が利用できます（<a href="#_コア_apithe_core_api">The Core API</a> を参照）。
例えば、クラスパスからインポートするけど、テストに含まれない製品コードや、JARファイルに含まないけど参照可能なコードを参照したい場合は次のように記述します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@AnalyzeClasses(importOptions = {DoNotIncludeTests.class, DoNotIncludeJars.class})</code></pre>
</div>
</div>
<div class="paragraph">
<p>As explained in <a href="#_コア_apithe_core_api">The Core API</a>, you can write your own custom implementation of <code>ImportOption</code>
and then supply the type to <code>@AnalyzeClasses</code>.</p>
</div>
<div class="paragraph">
<p><a href="#_コア_apithe_core_api">The Core API</a> で説明したように、<code>@AnalyzeClasses</code> には、自分で実装した <code>ImportOption</code> を指定できます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_キャッシュの制御controlling_the_cache"><a class="anchor" href="#_キャッシュの制御controlling_the_cache"></a>9.1.3. キャッシュの制御（Controlling the Cache）</h4>
<div class="paragraph">
<p>By default all classes will be cached by location. This means that between different
test class runs imported Java classes will be reused, if the exact combination of locations has already
been imported.</p>
</div>
<div class="paragraph">
<p>初期設定では、全てのクラスがインポートした位置と共にキャッシュされます。
つまり、複数のテストクラスで同じ位置からインポートしている場合、キャッシュを再利用できるのです。</p>
</div>
<div class="paragraph">
<p>If the heap runs low, and thus the garbage collector has to do a big sweep in one run,
this can cause a noticeable delay. On the other hand, if it is known that no other test class will
reuse the imported Java classes, it would make sense to deactivate this cache.</p>
</div>
<div class="paragraph">
<p>利用できるヒープメモリが狭すぎる場合や、GC のスイープ処理に時間がかかりすぎる場合は、無視できない遅れが発生します。
一方、インポートしたクラスを再利用するテストクラスが他に存在しないことが分かっているなら、キャッシュを破棄できることになります。</p>
</div>
<div class="paragraph">
<p>This can be achieved by configuring <code>CacheMode.PER_CLASS</code>, e.g.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">@AnalyzeClasses(packages = "com.myapp.special", cacheMode = CacheMode.PER_CLASS)</code></pre>
</div>
</div>
<div class="paragraph">
<p>The Java classes imported during this test run will not be cached by location and just be reused within
the same test class. After all tests of this class have been run,
the imported Java classes will simply be dropped.</p>
</div>
<div class="paragraph">
<p>このテストを実行してインポートした Java クラスは、位置に対してキャッシュしませんし、同じテストクラスの中でしか再利用しません。
このテストクラスの全てのテストが完了したら、インポートした Java クラスは単純に捨てることができます。</p>
</div>
</div>
<div class="sect3">
<h4 id="_テストの無視ignoring_tests"><a class="anchor" href="#_テストの無視ignoring_tests"></a>9.1.4. テストの無視（Ignoring Tests）</h4>
<div class="paragraph">
<p>It is possible to skip tests by annotating them with <code>@ArchIgnore</code>, for example:</p>
</div>
<div class="paragraph">
<p><code>@ArcIgnore</code> アノテーションを指定するとテストをスキップできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">public class ArchitectureTest {

    // will run
    @ArchTest
    public static final ArchRule rule1 = classes().should()...

    // won't run
    @ArchIgnore
    @ArchTest
    public static final ArchRule rule2 = classes().should()...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note for users of JUnit 5: the annotation <code>@Disabled</code> has no effect here.
Instead, <code>@ArchIgnore</code> should be used.</p>
</div>
<div class="paragraph">
<p>JUnit 5 を使っている場合は <code>@Disabled</code> アノテーションが無効になるので注意してください。
あくまでも <code>@ArchIgnore</code> を指定しなければなりません。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ルールのグループ化grouping_rules"><a class="anchor" href="#_ルールのグループ化grouping_rules"></a>9.1.5. ルールのグループ化（Grouping Rules）</h4>
<div class="paragraph">
<p>Often a project might end up with different categories of rules, for example "service rules"
and "persistence rules". It is possible to write one class for each set of rules, and then
refer to those sets from another test:</p>
</div>
<div class="paragraph">
<p>最終的にプロジェクトのルールはさまざまな分類に落ち着くことでしょう。
例えば、「サービスのためのルール」とか「永続化層のためのルール」とか。
それぞれの分類に対応するルールを1つのクラスとして記述し、テストから参照できます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">public class ServiceRules {
    @ArchTest
    public static final ArchRule ruleOne = ...

    // further rules
}

public class PersistenceRules {
    @ArchTest
    public static final ArchRule ruleOne = ...

    // further rules
}

@RunWith(ArchUnitRunner.class) // Remove this line for JUnit 5!!
@AnalyzeClasses
public class ArchitectureTest {

    @ArchTest
    static final ArchTests serviceRules = ArchTests.in(ServiceRules.class);

    @ArchTest
    static final ArchTests persistenceRules = ArchTests.in(PersistenceRules.class);

}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The runner will include all <code>@ArchTest</code> annotated members within <code>ServiceRules</code> and <code>PersistenceRules</code> and evaluate
them against the classes declared within <code>@AnalyzeClasses</code> on <code>ArchitectureTest</code>.
This also allows an easy reuse of a rule library in different projects or modules.</p>
</div>
<div class="paragraph">
<p>テストランナーは <code>ServiceRules</code> と <code>PersistenceRules</code> から <code>@ArchTest</code> アノテーションで修飾した全てのメンバーを抽出し、<code>ArchitectureTest</code> の <code>@AnalyzeClasses</code> で指定した全てのクラスに対して評価します。
他のプロジェクトやモジュールをルールライブラリとして再利用するのも簡単でしょう。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_高度な設定advanced_configuration"><a class="anchor" href="#_高度な設定advanced_configuration"></a>10. 高度な設定（Advanced Configuration）</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Some behavior of ArchUnit can be centrally configured by adding a file <code>archunit.properties</code>
to the root of the classpath (e.g. under <code>src/test/resources</code>).
This section will outline some global configuration options.</p>
</div>
<div class="paragraph">
<p>ArchUnit の振る舞いの一部は <code>archunit.properties</code> をクラスパスのルートに配置すると集中管理できるようになります（たとえば <code>src/test/resources</code> に配置するといいでしょう）。
このセクションでは大域的な設定オプションについて解説します。</p>
</div>
<div class="sect2">
<h3 id="_設定の上書きoverriding_configuration"><a class="anchor" href="#_設定の上書きoverriding_configuration"></a>10.1. 設定の上書き（Overriding configuration）</h3>
<div class="paragraph">
<p>ArchUnit will use exactly the <code>archunit.properties</code> file returned by the context
<code>ClassLoader</code> from the classpath root, via the standard Java resource loading mechanism.</p>
</div>
<div class="paragraph">
<p>ArchUnit は、Java の標準的なリソース読み取りの仕組みに従い、<code>ClassLoader</code> の発見したクラスパスのルートに配置されている <code>archunit.properties</code> の内容そのものを参照します。</p>
</div>
<div class="paragraph">
<p>It is possible to override any property from <code>archunit.properties</code>, by passing a system property
to the respective JVM process executing ArchUnit:</p>
</div>
<div class="paragraph">
<p><code>archunit.properties</code> で指定した設定項目は、ArchUnit を実行する JVM のシステムプロパティで上書きできます。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">-Darchunit.propertyName=propertyValue</code></pre>
</div>
</div>
<div class="paragraph">
<p>E.g. to override the property <code>resolveMissingDependenciesFromClassPath</code> described in the next section, it would be possible to pass:</p>
</div>
<div class="paragraph">
<p>例えば、次のセクションで説明する設定項目 <code>resolveMissingDependenciesFromClassPath</code> を上書きするときは、次のように指定します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">-Darchunit.resolveMissingDependenciesFromClassPath=false</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_解決のための振る舞いの構成configuring_the_resolution_behavior"><a class="anchor" href="#_解決のための振る舞いの構成configuring_the_resolution_behavior"></a>10.2. 解決のための振る舞いの構成（Configuring the Resolution Behavior）</h3>
<div class="paragraph">
<p>As mentioned in <a href="#_存在しないクラスの扱いdealing_with_missing_classes">Dealing with Missing Classes</a>, it might be preferable to configure a different
import behavior if dealing with missing classes wastes too much performance.
One way that can be chosen out of the box is to never resolve any missing class from the classpath:</p>
</div>
<div class="paragraph">
<p><a href="#_存在しないクラスの扱いdealing_with_missing_classes">Dealing with Missing Classes</a> で説明したように、存在しないクラスの扱いが重大な性能劣化に影響する場合、別のインポートの振る舞いをさせるほうが望ましいです。
1つの方法として、存在しないクラスをクラスパスから探索しない組み込みの振る舞いを選択できます。</p>
</div>
<div class="listingblock">
<div class="title">archunit.properties</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">resolveMissingDependenciesFromClassPath=false</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you want to resolve just some classes from the classpath (e.g. to import missing classes from
your own organization but avoid the performance impact of importing classes from 3rd party packages),
it is possible to configure only specific packages to be resolved from the classpath:</p>
</div>
<div class="paragraph">
<p>クラスパスから解決させたいクラスがいくつか存在するなら、特定のパッケージだけをクラスパスから解決させるように構成できます（例えば、あなたの会社内で利用しているクラスをクラスパスから解決させたいけど、サードパーティのパッケージを探索して性能劣化させたくない場合など）。</p>
</div>
<div class="listingblock">
<div class="title">archunit.properties</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">classResolver=com.tngtech.archunit.core.importer.resolvers.SelectedClassResolverFromClasspath
classResolver.args=some.pkg.one,some.pkg.two</code></pre>
</div>
</div>
<div class="paragraph">
<p>This configuration would only resolve the packages <code>some.pkg.one</code> and <code>some.pkg.two</code> from the
classpath, and stub all other missing classes.</p>
</div>
<div class="paragraph">
<p>このように設定すると、<code>some.pkg.one</code> と <code>some.pkg.two</code> のパッケージに所属するクラスをクラスパスから解決し、それ以外のクラスはスタブにすることができます。</p>
</div>
<div class="paragraph">
<p>The last example also demonstrates, how the behavior can be customized freely, for example
if classes are imported from a different source and are not on the classpath:</p>
</div>
<div class="paragraph">
<p>最後の例では、振る舞いの構成の自由度を示すことにします。
次のように設定すると、クラスパスではない別のファイルシステムパスからクラスをインポートできるのです。</p>
</div>
<div class="paragraph">
<p>First Supply a custom implementation of</p>
</div>
<div class="paragraph">
<p>まず、<code>ClassResolver</code> を実装したクラスを用意します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">com.tngtech.archunit.core.importer.resolvers.ClassResolver</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then configure it</p>
</div>
<div class="paragraph">
<p>そして次のように設定します。</p>
</div>
<div class="listingblock">
<div class="title">archunit.properties</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">classResolver=some.pkg.MyCustomClassResolver</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the resolver needs some further arguments, create a public constructor with one <code>List&lt;String&gt;</code>
argument, and supply the concrete arguments as</p>
</div>
<div class="paragraph">
<p>リゾルバーに引数が必要なら、<code>List&lt;String&gt;</code> 型の引数を1つ持つ public コンストラクタを作成すれば、次のように引数を設定できます。</p>
</div>
<div class="listingblock">
<div class="title">archunit.properties</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">classResolver.args=myArgOne,myArgTwo</code></pre>
</div>
</div>
<div class="paragraph">
<p>For further details, compare the sources of <code>SelectedClassResolverFromClasspath</code>.</p>
</div>
<div class="paragraph">
<p>より詳しい内容が知りたいときは <code>SelectedClassResolverFromClasspath</code> のソースコードを参照してください。</p>
</div>
</div>
<div class="sect2">
<h3 id="_クラスの_md5_チェックサムmd5_sums_of_classes"><a class="anchor" href="#_クラスの_md5_チェックサムmd5_sums_of_classes"></a>10.3. クラスの MD5 チェックサム（MD5 Sums of Classes）</h3>
<div class="paragraph">
<p>Sometimes it can be valuable to record the MD5 sums of classes being imported to track
unexpected behavior. Since this has a performance impact, it is disabled by default,
but it can be activated the following way:</p>
</div>
<div class="paragraph">
<p>インポートするクラスの MD5 チェックサムを記録しておくと、予期せぬ振る舞いの調査に役立つ場合があります。
この機能は性能に影響するため初期設定では無効になっていますが、次のように有効化できます。</p>
</div>
<div class="listingblock">
<div class="title">archunit.properties</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">enableMd5InClassSources=true</code></pre>
</div>
</div>
<div class="paragraph">
<p>If this feature is enabled, the MD5 sum can be queried as</p>
</div>
<div class="paragraph">
<p>この機能を有効化していると、次のように MD5 チェックサムを取得できるようになります。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">javaClass.getSource().get().getMd5sum()</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_エラーメッセージのカスタマイズcustom_error_messages"><a class="anchor" href="#_エラーメッセージのカスタマイズcustom_error_messages"></a>10.4. エラーメッセージのカスタマイズ（Custom Error Messages）</h3>
<div class="paragraph">
<p>You can configure a custom format to display the failures of a rule.</p>
</div>
<div class="paragraph">
<p>ルールの評価に失敗したときに表示するメッセージの書式を設定できます。</p>
</div>
<div class="paragraph">
<p>First Supply a custom implementation of</p>
</div>
<div class="paragraph">
<p>まず、<code>FailureDisplayFormat</code> を実装したクラスを用意します。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">com.tngtech.archunit.lang.FailureDisplayFormat</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then configure it</p>
</div>
<div class="paragraph">
<p>そして次のように設定します。</p>
</div>
<div class="listingblock">
<div class="title">archunit.properties</div>
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-none hljs">failureDisplayFormat=some.pkg.MyCustomFailureDisplayFormat</code></pre>
</div>
</div>
<div class="paragraph">
<p>One example would be to shorten the fully qualified class names in failure messages:</p>
</div>
<div class="paragraph">
<p>例えば、失敗メッセージの中で完全修飾クラス名の短縮形にしたい場合は次のようにします。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code data-lang="java" class="language-java hljs">private static class SimpleClassNameFailureFormat implements FailureDisplayFormat {
    @Override
    public String formatFailure(HasDescription rule, FailureMessages failureMessages, Priority priority) {
        String failureDetails = failureMessages.stream()
                .map(message -&gt; message.replaceAll("&lt;(?:\\w+\\.)+([A-Z][^&gt;]*)&gt;", "&lt;$1&gt;"))
                .collect(joining(lineSeparator()));

        return String.format("Architecture Violation [Priority: %s] - Rule '%s' was violated (%s):%n%s",
                priority.asString(), rule.getDescription(), failureMessages.getInformationAboutNumberOfViolations(), failureDetails);
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that due to the free format how violation texts can be composed,
in particular by custom predicates and conditions,
there is at the moment no more sophisticated way than plain text parsing.
Users can tailor this to their specific environments where they know
which sorts of failure formats can appear in practice.</p>
</div>
<div class="paragraph">
<p>特に独自の述語式と条件式を使っている場合はそうなのですが、違反の説明文は自由に構成できるため、今のところ平文テキストを解析する以外に効率的な方法はありません。
ユーザーは、自身の環境で実際にどのような書式の失敗メッセージが得られるのか試してみるしかありません。</p>
</div>
</div>
</div>
</div>
</div>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/mono-blue.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlighting()</script>
</body>
</html>