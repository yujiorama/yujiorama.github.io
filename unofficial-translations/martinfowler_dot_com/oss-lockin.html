<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>ロックインを避けることに縛られないで！</title>
  <style>
    html {
      line-height: 1.5;
      font-family: Georgia, serif;
      font-size: 20px;
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      word-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 1em;
      }
    }
    @media print {
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, 'Lucida Console', Consolas, monospace;
      font-size: 85%;
      margin: 0;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      background-color: #1a1a1a;
      border: none;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header id="title-block-header">
<h1 class="title">ロックインを避けることに縛られないで！</h1>
</header>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#dont-get-locked-up-into-avoiding-lock-inロックインを避けることに縛られないで">Don't get locked up into avoiding lock-in（ロックインを避けることに縛られないで）</a>
<ul>
<li><a href="#オープンソースやハイブリッドマルチクラウドはロックインじゃない">オープンソースやハイブリッド、マルチクラウドはロックインじゃない？</a></li>
<li><a href="#いろいろなロックイン">いろいろなロックイン</a></li>
<li><a href="#モデルを利用して優れた意思決定をする">モデルを利用して優れた意思決定をする</a></li>
<li><a href="#2次元マトリクスで考えるロックイン">2次元マトリクスで考えるロックイン</a></li>
<li><a href="#本来のロックインのコスト">本来のロックインのコスト</a></li>
<li><a href="#ロックインを軽減する方法それは行使価格">ロックインを軽減する方法、それは行使価格</a></li>
<li><a href="#ロックインを回避するための合計コスト">ロックインを回避するための合計コスト</a></li>
<li><a href="#まとめ">まとめ</a></li>
<li><a href="#アーキテクチャについて思考する速度">アーキテクチャについて思考する速度</a></li>
</ul></li>
</ul>
</nav>
<hr />
<p>注意書きここから</p>
<ul>
<li>この文章は、2019年9月9日に<a href="https://martinfowler.com/">martinfowler.com</a>で公開された、Gregor Hohpe氏の寄稿した<a href="https://martinfowler.com/articles/oss-lockin.html">Don't get locked up into avoiding lock-in</a>を翻訳したものです。</li>
<li>翻訳により混入した誤りの責任は<a href="https://github.com/yujiorama">Yuji Okazawa</a>に帰属します。</li>
</ul>
<p>注意書きここまで</p>
<hr />
<h1 id="dont-get-locked-up-into-avoiding-lock-inロックインを避けることに縛られないで">Don't get locked up into avoiding lock-in（ロックインを避けることに縛られないで）</h1>
<p>アーキテクチャに関係する労力の大部分は、ロックインを軽減したり避けたりすることに費やされています。 結構壮大な目標です。なぜならアーキテクチャは選択肢を与えてくれるもので、ロックインはその反対を意味するからです。 ですが、ロックインは単純に白黒つけられる問題ではありません。 ロックインを回避しようとするため別の何かに縛られてしまう場合もあるからです。 また、一部ではOSSが魔法のようにロックイン問題を解決してくれるなどと言われていますが、完全に間違っています。 ロックインについて詳しく理解する時間を設けるようにすれば、回避すること自体に縛られてしまうことを避けられるでしょう。</p>
<hr />
<p>アーキテクトの主な目的の1つは「<a href="https://architectelevator.com/architecture/architecture-options/">選択肢を作る</a>」です。 選択肢があるとシステムは変更に強くなります。 私たちはより多くの情報が得られるまで、あるいは予期せぬ出来事に対応しなければならなくなるまで決定を先延ばしにできるのです。 「ロックイン」は真逆の状態をもたらします。 あるソリューションから別のソリューションへの変更を困難にしてしまうのです。 だから多くのアーキテクトは相互接続可能なコンポーネントを自由に交換できるITシステムの世界を守る守護者としてロックインを敵視するのです。</p>
<p>しかし、単純なままでいられるアーキテクチャはほとんど存在しません。 ビジネスとのトレードオフがあるからです。 経験豊富なアーキテクトなら、ロックインにはそれを回避しなければならないという一般的な意見よりずっと奥深い何かがあることを理解しています。 ロックインにはさまざまな側面があるし、中には素敵なソリューションとして採用できるものすらあるのです。 そういうわけで、ロックインについて詳しく理解するため「<a href="https://martinfowler.com/articles/architect-elevator.html">アーキテクトエレベーター</a>」に搭乗してみましょう。</p>
<hr />
<h2 id="オープンソースやハイブリッドマルチクラウドはロックインじゃない">オープンソースやハイブリッド、マルチクラウドはロックインじゃない？</h2>
<p>私たちがソフトウェアをデプロイするようになった、かつてないほどに強力で近代的なクラウドプラットフォームは、<a href="https://www.slideshare.net/bretmc/machine-learning-with-google-machine-learning-apis-puppy-or-muffin">アップロードした写真が子犬かマフィンか見分ける</a>だけでなく、ソースコードをコンパイルしたりその結果をデプロイしたり、必要なインフラを構成したり、私たちのデータを格納したりします。 この素晴らしい利便性と生産性の加速装置は、今までにない新しい形態のロックインをもたらします。 近年多くのアーキテクトの注目を集めているハイブリッドあるいはマルチクラウドの構成は、新しい種類のロックインについて考察するちょうどいい例になります。 まず、クラウドプラットフォームにデプロイしたいアプリケーションがあることにしましょう。 やることは簡単ですが、アーキテクトとしての視点にはさまざまな選択肢が見えているでしょうし、特にロックインに関係するより多くのトレードオフも見えているでしょう。</p>
<p>アプリケーションをコンテナにデプロイしたいと思うかもしれません。 いいことですね。ですが、そのために<a href="https://aws.amazon.com/ecs/">AWS ECS</a>を使わなければならないのでしょうか。 それってAWSのプロプライエタリサービスですよね。 Kubernetesのほうがいいですか。 OSSですし、オンプレミス環境を含むたいていの環境で実行できますよね。 それで問題は解決するんですか。 たぶんなんですがKubernetesマニフェストのYAML地獄で混乱しているんじゃないですか。 要するに、あなたはロックインと別の何かを交換条件にしたんですよ。わかってますか。 また、Google GKEやAmazon EKSや Azure AKSなどのマネージドKubernetesサービスを使っているなら、Kubernetesのバージョン依存やプロプライエタリの拡張機能に悩まされているかもしれませんね。</p>
<p>オンプレミス環境でソフトウェアを実行しなければならないとしたら、<a href="https://aws.amazon.com/outposts/">AWS Outposts</a>を利用することもできるでしょう。 そうすればいろんな選択肢が利用できます。 ただ、繰り返しになりますがそれはプロプライエタリ製品です。 あなたがかつてロックインされていたであろうVMWareと統合するとして、これまでとどんな違いがあると言うのでしょうか。 Googleもほとんど同じことをする新しいサービスのAnthosを提供しています。こちらはOSSコンポーネントで構築されているのですがプロプライエタリ製品として導入するしかありません。 それでも、Anthosを維持している限りアプリケーションを別のクラウドへ移行できるのです。 これってロックインの定義そのものじゃないですか。</p>
<p>たとえ自動化したデプロイの仕組みから、アプリケーションの実行環境をきれいに分離できているとして、ロックインに関するあらゆるコストを相殺するほどインフラストラクチャの切り替えが簡単にできるわけではありません。 世の中にはクロスプラットフォームに対応したIaC（Infrastructure-as-code）ツールもありますが、そういう懸念を解消してくれるわけではありません。</p>
<p>ストレージが必要になったらAWS S3を使うんですか。 他のクラウドプロバイダーもS3と互換性のあるAPIを提供しているので、たとえプロプライエタリ製品であってもS3はマルチクラウドに対応したロックインフリーだと言えるでしょうか。 結局ストレージへアクセスする抽象化レイヤを設けて、それぞれの依存先ごとに実装を用意することになると思うのですけど、それが賢い方法なんでしょうか。</p>
<p>どう考えてもロックインの回避は困難を極めることになりそうですし、それだけでいっぱいいっぱいになってしまいそうです。 著者はもう少しクラウドアーキテクチャの楽しさに浸っていたいので、サイモン・ウォードレイの紹介しているハイブリッドクラウドに向かうのはもう少し後にしようと思います。</p>
<p><a href="https://twitter.com/swardley/status/908031162668474368"><a href="https://twitter.com/swardley/status/908031162668474368">https://twitter.com/swardley/status/908031162668474368</a></a></p>
<hr />
<h2 id="いろいろなロックイン">いろいろなロックイン</h2>
<p>エレベーターに乗ったアーキテクト（登ったり下ったりする<a href="https://architectelevator.com/">アーキテクトエレベーター</a>に搭乗している人）は、大半の人には白と黒しか見えないところへ影を見出すことができるようになります。 システム設計について考えているなら、ロックインや結合のように一般的な特徴は2値で表せないことに気づくのです。 2つのシステムは単純に結合したり分断したりするわけではないのと同様に、単純になんらかの製品へロックインしているわけではないのです。 それぞれの特徴には多くの微妙な意味合いがあります。 例えば、ロックインなら次のようにいろいろな側面へ分解できます。</p>
<ul>
<li><strong>ベンダーロックイン</strong> IT業界で「ロックイン」という表現をするときは一般的にこちらの意味になります。 この言葉はあるベンダーから別のベンダーへ切り替えることの難しさを説明するものです。 例えば、Siebel CRMからSalesForce CRMへ、あるいは、IBM DB2からOracleへ移行するコストはとても高くつきます。あなたは「ロックイン」されているのです。 この種類のロックインは基本的にベンダーにとって多かれ少なかれ利益になるのが一般的です。 長期間のライセンス契約やサポート契約を締結することで、ライセンス費用の割引が可能になるなど営利的な取り決めを含むこともあります。</li>
<li><strong>製品ロックイン</strong> ベンダーロックインと関係するけど、製品にロックインされるところが違います。 あるベンダーの製品から別のベンダーの製品に移行するとき、普通はベンダーと製品を両方変更することになります。そうすると簡単に一緒くたになってしまいます。 OSS製品を使えばベンダーロックインを避けられるかもしれません。ですが、製品ロックインからは逃れられません。 KubernetesやCassandraを使っているなら、それらの製品のAPIや設定やフィーチャにロックインされているということです。 本物の環境（特にエンタープライズ）で仕事をしているなら商用サポートも必要になるはずです。つまり前述したベンダーの契約に縛られるということです。 過剰なカスタマイズや統合点、プロプライエタリ拡張が製品ロックインを加速します。 たとえOSSを利用しているとしても、他の製品への切り替えを困難にするのです。</li>
<li><strong>バージョンロックイン</strong> 製品にロックインされているのに加えて、特定のバージョンに縛られてしまう場合があります。 自分たちで開発した既存のカスタマイズや拡張があるなら、バージョンアップはコストのかかる作業になります（SAPのことだよ）。 また、AngularJSからAngular2へのバージョンアップのように、根本的なアプリケーションの作り直しを要求するバージョンアップもあります。 さらに悪いことに、バージョンロックインは他の部分へ波及します。 ある製品のバージョンが特定のOSのバージョンに依存するような場合、あらゆる移行の試みは<a href="http://0xcc.net/blog/archives/000196.html">ヤクの髭剃り</a>へ挑戦するのと変わらないことになってしまいます。 特に、ベンダーがあなたの利用しているバージョンや製品ラインの廃止を決定するようなことになったらつらい思いをするのは間違いありません。 サポート無しでサービスを続けるか、完全なオーバーホールをするか選ばなければなりません。 古いバージョンに致命的な脆弱性が発見されたのにセキュリティパッチを提供してもらえないとか、そういうこともあり得ます。</li>
<li><strong>アーキテクチャロックイン</strong> ある種のアーキテクチャにロックインされてしまうこともあります。 Kubernetesを広く使っているとして、おそらく小さな素晴らしいサービスで構築したAPIを公開し、コンテナにデプロイしていることでしょう。 もしサーバーレスアーキテクチャへ移行したければ、サービスの粒度が単一の関数に近づくように改修したり、状態管理を外部化したり、イベント駆動アーキテクチャを活用したり、その他にもいろんなことに対応しなければならないでしょう。 決して小規模な変更では済みません。それどころかアプリケーションアーキテクチャを完全にオーバーホールすることになるのです。</li>
<li><strong>プラットフォームロックイン</strong> 製品ロックインの特殊な場合、つまりクラウドプラットフォームのことです。 プラットフォームはアプリケーションを実行する以外に、ユーザーアカウントやアクセス権限を管理したり、セキュリティポリシーやインフラストラクチャの隔離などいろんなことをします。 ストレージや機械学習のようにアプリケーションレベルのサービスを提供する場合もあります。もちろんプロプライエタリです。 そういうサービスを避けるようにすればプラットフォームロックインを軽減できていると思うかもしれないけど、そもそもクラウドに移行した一番の理由を否定することになります。 ソフトウェアの専門家でない人たちはそういう状況を「岩に挟まれて動けない状態（between a rock and hard place）」と呼んでいます。</li>
<li><strong>スキルロックイン</strong> 開発者たるあなたは、さまざまな製品やアーキテクチャを扱うことでスキルにロックインされてしまいます。 別の製品や技術を求められる開発者としての訓練（あるいは雇用）に時間がかかるということです。 今日のIT業界ではスキルを保持していることが重要な制約となるので、このロックインは深刻なのです。 ニッチな製品を扱える開発者の数は極めて限られているため、開発者のコスト（採用や教育）が増加します。 独自のプログラミング言語や、皮肉なことに「設定だけで動く」あるいはノーコードなフレームワークを提供する製品においてそのような影響は顕著になります。</li>
<li><strong>法律ロックイン</strong> コンプライアンスなど法律上の理由で特定のソリューションにロックインされるかもしれません。 例えば、データセンターが外国にあるクラウドプロバイダーには移行できない場合があります。 また、あなたの利用しているソフトウェア製品のライセンスが、たとえ完全に動作するのが分かっているとしても、システムをクラウドへ移行できないよう制限する場合があります。 無視すればライセンス条項違反になってしまいます。 法的な側面はエンジニアリング作業のさまざまな側面について、思っているよりもずっと広い範囲に影響します。 たとえば、あなたが原動機付き飛行機を自作したとして、そのエンジンは1970年代に設計された有鉛燃料を燃焼するエンジンかもしれません。現代ではそのような燃料の使用は法律で規制されています。</li>
<li><strong>メンタルロックイン</strong> あなたの思考に影響する最も繊細で最も危険なロックインです。 何社ものベンダーやいくつものアーキテクチャに取り組んだ後には、おそらく意思決定にいろいろな思い込みが入り込んでしまうはずです。 そして、その思い込みは代替案を排除してします。 例えば、スケールアウトアーキテクチャの非効率性（線形にスケールしない：ハードウェアを2倍にしても性能は2倍にならない）が気になって却下してしまうかもしれないのです。 そういう思考は技術的に正しいかもしれませんが、効率性ではなく拡張性が主な動機であるという事実を無視してしまうのです。 短いリリースサイクルで仕事していたとき、頻繁な変更により多数の不具合を混入した経験があるとか、とにかくコーディングは時間がかかるし間違いやすいと思っているとしたら、全てを設定だけで動かすほうがいいと考えることでしょう。</li>
</ul>
<p>まとめると、ロックインは全部かゼロかという判断からは程遠いものです。 それゆえに、さまざまな側面を理解すればより意識的に意思決定できるようになるのです。 この一覧はOSSが魔法のようにロックインを解消してくれるという間違った幻想を打ち砕くものです。 OSSはベンダーロックインを軽減してくれるかもしれませんが、他の種類のロックインはそのままです。 だからといってOSSが悪いわけでもなく、ロックインを取り除く魔法なんてないんだよということです。</p>
<hr />
<h2 id="モデルを利用して優れた意思決定をする">モデルを利用して優れた意思決定をする</h2>
<p>経験豊富なアーキテクトは白と黒の混ざった部分を見分けるだけでなく、意思決定のための優れた規律に従っています。 私たちは自分で思っているより意思決定者としては凡庸なので、（規律に従うことは）重要です。 信じられなければ<a href="https://www.amazon.com/gp/product/0374533555/">ダニエル・カーネマンのThinking, Fast and Slow</a>を読んでみるといいでしょう。 モデルを利用するのは意思決定のためのより良い方法の1つです。 特に単純なモデルでさえ驚くほどの効果を発揮するのです。</p>
<blockquote>
<p>単純でも感情に訴えかけるモデルは優秀な科学者の証です。しかし、過剰に洗練されているとかパラメータ化をやりすぎているモデルは月並みな能力しかないことを示しています。 -- <a href="https://en.wikipedia.org/wiki/All_models_are_wrong#Quotations_of_George_Box">George Box</a></p>
</blockquote>
<p>経営コンサルタントも愛用する有名な2次元のマトリクスを笑い飛ばすべきではありません。 自分たちもいつか発見するかもしれない簡潔で効果的なモデルの1つなのですから。 モデルについてもう1つ重要な点があります。 一般的に言われているように、不確実性に向き合っているときは「考えずに衝動的に行動しなければなりません（shoot from the hip）」。結局のところすべては流動的なのです。 もちろん正反対の意見もあります。 基本的に私たちの愚かな意思決定がより悪い結果をもたらすのは、多数の相互依存性を扱わなければならないとか、不確実性が高いとか、成功する可能性が低いとかそういう場合だけです。 そういうときモデルを活用すれば、意思決定のためにより適切な構造や規律を整えることができるでしょう。 ロックインの落とし穴に飛び込んでみるとして、どれくらいまで許容するか判断する問題はこの議論の範疇に含まれます。 というわけでモデルを活用していきましょう。</p>
<hr />
<h2 id="2次元マトリクスで考えるロックイン">2次元マトリクスで考えるロックイン</h2>
<p>簡潔なモデルを利用すると「ロックイン=悪」という思考停止の罠を避けられるようになります。 まず、私たちが認識しなければならないのは、何者にもロックインされないでいるのは困難であるという事実です。 ある程度のロックインは避けられないのです。 次に、私たちはある程度のロックインを許容することで相応の利益が得られるならたぶん幸せになれます。 例えば、競合製品にない独自機能や独自の使い方がある場合など。</p>
<p>それぞれの要因を2次元マトリクスという簡単なモデルで考えてみましょう。</p>
<p><a href="https://martinfowler.com/articles/oss-lockin/lockin_matrix.png">原文の図を参照してください</a></p>
<p>このマトリクスの縦軸（切り替えコスト）と横軸（独自機能）は次のような意味です。</p>
<ul>
<li>切り替えコスト（ロックイン） 他のソリューションへの切り替えるはどれくらい難しいか</li>
<li>独自機能 他のソリューションと比べて独自機能からどれだけの利益を得られるか</li>
</ul>
<p>そうするとそれぞれの4象限は次のように考えることができます。</p>
<ul>
<li><strong>使い捨て</strong> 独自機能もなく、置き換えの容易なコンポーネントについて特別な配慮は不要です。 そのまま利用して、何か問題が起きたら別の何かに切り替えればいいのです。 ありふれた仕事をさせるだけなら悪くない選択肢だと思います。 ほとんどの開発者の利用するIDEはこの分類になるんじゃないでしょうか（ただしEmacsは別だけどな 🙂 ）。 自分が快適に過ごせるよう好きに組み合わせて、拘り過ぎないようにするだけです。 個人の写真などの個人データを格納するクラウドストレージも、スマートフォンデバイスをこの分類に移動することになりました。詳しくは後述します。</li>
<li><strong>ロックインを受け入れる</strong> 特定の製品やベンダーにロックインされているけど独自機能などの見返りを得ている状態です。 基本的にロックインを減らすことを推奨されているのですが、そういうトレードオフは許容されやすいです。 Google Cloud BigQuery とか AWS Bare Metal インスタンスとかの製品はロックインされていることを意識しながら利用することになるでしょう。利益に基づいて慎重に決定すればいいのです。 小さなアプリケーションならたぶん移行も発生しないでしょうし、開発や運用コストの節約が勝るので、AWSの独自サービスを利用することにしてもいいんじゃないでしょうか。</li>
<li><strong>注意</strong> 最も好ましくないのは、ロックインされているけど特に独自機能も利用していない状態です。 伝統的なRDBはこの象限に該当します。 プロプライエタリなデータベースは本当に利益向上に役立っているんですか。そんなことないですよね。 移行しようと思ったら大変なことになるので、そうならないことを確認しておかなければなりません。 宇宙空間で稼働する組み込みシステムのために特別なハードウェアを選択するのはOKです。移行する可能性は極めて低いからです。</li>
<li><strong>理想</strong> 独自機能を活用できていると同時に、他のソリューションへの切り替えも容易な理想的な状態です。 理想論なのでこの状態を目標とするなら矛盾があることを承知しておかないといけません。 競合製品は、あるソリューションが提供する独自機能を提供していません（だから独自なんですけど）。だから移行は困難です。 AWS S3は恰好の例です。 複数のクラウドベンダーは同じAPIを提供するようになっており、実際にGCPへ切り替えるのも比較的簡単です。 ですが、それぞれのベンダーの実装は局所性や性能などに有意な差があるのです。 そもそも、同一のAPIを提供する別のベンダーへ移行できるとか、そういうポータビリティを重視するなら、<a href="https://en.wikipedia.org/wiki/Google_LLC_v._Oracle_America,_Inc.">今のところAPIには特許権が認められていない（GoogleとOracleの訴訟）</a>ことを覚えておかなければなりません。</li>
</ul>
<p>簡潔なモデルにソフトウェアコンポーネントを配置してみるのはいい実験になります。 あなたの理解を可視化するだけでなく、さまざまなステークホルダーに対するあなたの決定を伝えてくれるからです。</p>
<p><a href="https://martinfowler.com/articles/oss-lockin/lockin_example.jpg">原文の図を参照してください</a></p>
<p>普段使っているソフトウェアをマトリクスに配置してみると、いろいろなモノについてさまざまなロックインの度合を判断をしているのが分かるでしょう。 右上から反時計回りに説明しています。</p>
<ul>
<li><strong>iPhone</strong>はあなたをベンダーエコシステムにロックインしますが独自機能を提供します。あなたはそれを承知しているためこれは <strong>Accepted Lock-in</strong>です</li>
<li><strong>通信事業者との契約</strong>はあなたを単独のネットワークに縛りつけますが、独自のネットワーク機能を提供するわけではありません。したがって <strong>Caution</strong>です</li>
<li>あなたの <strong>充電器</strong>は標準規格に従っています。残念ながらほとんどのiPhoneはそうではありません。たまたまその辺にあったアダプターで接続できたのでこれは <strong>Disposable</strong>です。</li>
<li><strong>メッセージングなどのいろいろなアプリ</strong>は独自機能を提供しますが、切り替えしやすいように設計されています。連絡帳アプリを使ってみると分かるでしょう。だからこれは <strong>Ideal</strong>です。</li>
</ul>
<p>「独自機能」という言葉について注意点があります。 あらゆるベンダーは何らかの独自機能を提供しているはずです。それが差別化の方法だからです。 ですが、今はそういった機能をあなたに提供する独自の価値や、具体的な機能へ変換した前提で議論しています。 例えば、あるクラウドプロバイダーが地球規模のネットワークで1億人規模のユーザーがいるサービスを提供していることにしましょう。 それはそれで素晴らしいことなのですが、100万人の顧客が対象であるとか、単一の国へ限定したサービスであるとか、そういう平均的なエンタープライズシステムにとって役に立つ可能性は低いのです。 国土は狭いし速度制限もあるような国でフェラーリを購入するような人もいるのですが、あらゆる意思決定が合理的でなければならないわけでもありませんし、たぶんクラウドプラットフォームよりはいろいろと役に立つ場面があるのでしょう。</p>
<hr />
<h2 id="本来のロックインのコスト">本来のロックインのコスト</h2>
<p>単純なマトリクスが便利なのは分かってもらえたと思うので別の例を見てみましょう。 前の例では「切り替えのコスト」を軸にしていました。 優秀なアーキテクトはそれをさらに2つの軸へ分割できます。</p>
<p><a href="https://martinfowler.com/articles/oss-lockin/lockin_cost.png">原文の図を参照してください</a></p>
<p>このマトリクスは、切り替えのコストと、切り替えが必要になる可能性の関係を示しています。 切り替えが必要になる可能性は低いし、コストも低い要素は特に問題にならないはずです。 一方、対角線上に位置する、切り替えが必要になる可能性が高く、高コストな要素は良くないので何かしら対応しなければなりません。 コストはかかるけど切り替えが必要になる可能性が低い要素を選択するなら、変更スコープを制限するとか、保守費用を割り増しにするなどの保険をかけたくなるはずです。 リスクを引き受けないといけない場合もあるでしょう。 実際にOracleからDB2へ移行しなければならない場合がどれほどあるというのでしょう。 切り替えが必要になる可能性は高いけど、コストは低い要素では「アジリティ」を実践することになるでしょう。 変化を受け入れながら低コストで実行できるシステムを設計するのです。 おかしな話ですが、「アジリティ」は「ギャンブル」と比べて小さな変更を頻繁に追加できるにも拘わらず注目されにくいのです。 それは私たちが凡庸な意思決定をしているせいでもあります。 ドラマが注目を集めるのは次に何が起きるのか分からないからなのです。</p>
<p>ロックインの可能性について議論していると、切り替えのためのいろいろなシナリオを検討したくなるものです。 ベンダーが事業をたたんでしまうとか、値上げするとか、あなたのシステムの規模や機能に見合うサポートを提供しなくなるとか。 面白いことに、ロックインを軽減したい気持ちはある種の交渉における道具になります。 ライセンスの更新について交渉するとき、自分たちのシステムは他の製品への切り替えは簡単に安価に実現できるアーキテクチャになっているんだよと、ベンダーの担当者に教えてあげることもできるのです。 あなたたちのBATNA（<a href="https://en.wikipedia.org/wiki/Best_alternative_to_a_negotiated_agreement">Best Alternatives To a Negotiated Agreement</a>）を伝えることで値引き交渉を有利に進められるようになります。 これはアーキテクチャとしての選択肢であって、実際にそうするとは限りません。 冷戦下における備蓄兵器のように抑止力として働くのです。 本当にロックインを軽減できているわけではなくても嘘をつくことは可能です。 ただ、ベンダーが嘘を見抜くこともあるので、休憩時間にウォーターサーバーの周辺で開発者とおしゃべりでもして狡猾なポーカープレイヤーになるのを目指しましょう。</p>
<hr />
<h2 id="ロックインを軽減する方法それは行使価格">ロックインを軽減する方法、それは行使価格</h2>
<p>著者らの書いた<a href="https://architectelevator.com/architecture/architecture-options/">オプション売買のアナロジー</a>をもう一度最初から読み直してみてください。 ロックインの回避がオプションに相当するとしたら、切り替えのコストはオプションの行使価格と考えられるのです。つまり、オプションを行使するときに支払う価格ということです。 行使価格が低ければ切り替えのコストは低いことになるし、高ければ価格よりオプションの価値が高くなるということです。 すべてのシステムが切り替えコストを最小化する「緑の範囲（green box）」に収まっているのが一番ですが、必要な投資が実際に報われるかは別の話です。</p>
<p>例えば、多くのアーキテクトはデータベースベンダーやクラウドプロバイダーにロックインされることを嫌がります。 ですが、実際に切り替えが必要になる可能性はどれくらいあるというのでしょうか。 5%でしょうか、もっと低いかもしれません。 手作業を含む切り替えのコストを$50,000をできるだけ0に近づけて欲しいと言われたらどうしますか。 ほとんどの場合、節約できる費用の期待値は$2,500($50,000*5%)より大きくなるでしょう。 だから切り替えのコストを最小化することを単独の目標にするべきではありません。すぐ過剰投資になってしまうからです。 保険金をかけ過ぎるのと同じです。税金の控除額が0へ近づくことに関心が向くかもしれないけど、たいていの場合それは経済的な得になりません。たとえそれが合理的な判断であったとしても。</p>
<p>最後のモデル（マトリクスじゃないけど）は切り替えのコストを減らすためにどれだけ投資すればいいのか判断するのを助けてくれます。 次のグラフでは、青の曲線で負債（前払いの投資額に応じた切り替えの発生する可能性と、製品の切り替えコストを掛け算した値）をプロットしています。</p>
<p><a href="https://martinfowler.com/articles/oss-lockin/option_switching_cost.png">原文の図を参照してください</a></p>
<p>オプションに投資すると負債が減少するのは明らかです。切り替えの可能性が低下する場合もありますし、行使価格が低下する場合もあるでしょう。 例えば、<a href="http://hibernate.org/orm/">Hibernate</a>のようなORMフレームワークを採用することは、データベースベンダーへのロックインを軽減する小さな投資になります。 データベースの固有のストアドプロシージャへ変換するメタプログラミング言語を作成することもできるでしょう。 そうすればロックインを避けながらデータベースの性能を十全に活用できるようになるのですが、事前の投資が必要になるためあり得そうにないシナリオです。</p>
<p>総額（前払いの投資額と潜在的な負債を足し算した値）をプロットした赤の曲線は面白い特徴を示しています。 あなたが最小化しなければならないのはこの総額です。 ほとんどの場合、前払いの投資額が増えると最適区間に移動していきます。 ロックインを回避するための投資を追加すると、総額は上昇していきます。 理由は簡単で、切り替えが必要になる可能性も低下するため投資に対する見返りが減少するからです。 他で見ないほどアーキテクチャを柔軟にするとしたら、過剰投資の区間に入ってしまうでしょう。 <a href="https://martinfowler.com/bliki/Yagni.html">Yagni</a>の信奉者はその対極（過少投資）に位置することでしょう。 ありきたりの考え方になりますが、中庸を保つことが成功の秘訣です。</p>
<hr />
<h2 id="ロックインを回避するための合計コスト">ロックインを回避するための合計コスト</h2>
<p>さて、私たちはロックインについてコストや潜在的な支払額がどうなるかいい感じに理解できたでしょう。 次は「ロックインを回避する」ための合計コストについて詳しく理解していきます。 前のモデルではロックインを回避するためのコストを単純にモデル化していましたが、もう少し細かく分割できるのです。</p>
<ul>
<li><strong>労力</strong> 人月で計測されるような追加で必要になる作業のことです。 クラウドプロバイダーへのロックインを避けるためコンテナをKubernetesにデプロイすることにしたなら、新しいツールやDockerfileの書き方やKubernetesの設定の仕方を学習しなければならないのです。</li>
<li><strong>費用</strong> 追加で必要になる費用のことです。 製品ライセンスとか、外部業者の調達費用とか、KubeConへの参加費用とか。</li>
<li><strong>不十分な活用</strong> ロックインを避けようと思ったらベンダー固有の機能を使えなくなるため、間接的な発生するコストです。 その結果、あなたのソフトウェアは製品の機能を十分に活用できない状態になります。 また、不足している機能を補うために自作するなどいろいろ苦労することになるし、そうするとあなたの製品の弱点を作り出してしまうかもしれないのです。</li>
<li><strong>複雑性</strong> 複雑性は数式の中心的な要素となるべきなのに無視されがちな要素です。 ロックインを軽減するためのさまざまな努力により抽象化のレイヤーが追加されていきます。 JDBCやコンテナや共通APIなど。 どれも便利な道具ですがそういうレイヤーは動作点を追加することになり、全体としてのシステムは複雑化します。 そうすると新しいチームメンバーがシステムについて学習するのは大変になるし、エラーが発生したときに問題を調査するのが大変になります。</li>
<li><strong>新たなロックイン</strong> あるロックインを回避すると別の何かにロックインしてしまうのはよくあることです。 たとえば、<a href="https://aws.amazon.com/cloudformation/">AWS CloudFormation</a>から複数のクラウドプロバイダーに対応している<a href="https://www.terraform.io/">Hashicorp Terraform</a>や<a href="https://www.pulumi.com/">Pulumi</a>へ切り替えようとしていることにします。 結局別のベンダーが提供する別の製品へロックインされることになるので、あなたはそれを認識して納得しなければなりません。</li>
</ul>
<p>ロックインを回避するためのコストを計算するとき、アーキテクトは見落とすことが無いようにこれらの一覧をすぐ書き出せるようにしないといけません。 また、ロックインの回避は<a href="https://architectelevator.com/architecture/failure-doesnt-respect-abstraction">漏れの多い抽象化</a>そのものであることを十分に認識しなければなりません。 例えば、Terraformはいいツールですが利用するスクリプトにはさまざまなベンダー固有の要素が登場します。 実装の詳細はそういう風に「漏れてくる」のです。 ですから、別のクラウドプロバイダーへの切り替えコストは決して0にならないのです。</p>
<hr />
<h2 id="まとめ">まとめ</h2>
<p>いろいろ理屈を説明してきたので、この節では具体例を紹介します。</p>
<h3 id="コンテナへのデプロイ">コンテナへのデプロイ</h3>
<p>アプリケーションコードをDockerコンテナにパッケージングして<a href="https://aws.amazon.com/ecs/">AWS ECS</a>へデプロイしている会社で働いていることもありました。 つまりAWSにロックインされていたのです。 KubernetesのようにOSSのコンテナオーケストレーターへの切り替えに投資するべきでしょうか。 その時はサービス開発のベロシティが中心的な関心事で、ECSは十分に上手く機能していました。 だから著者は移行しても得はないと考えました。 他のクラウドプロバイダーへの切り替えが必要になる可能性は低いし、「もっと大切な仕事があった（bigger fish to fly）」があったのです。</p>
<p><strong>助言</strong>：ロックインを受け入れましょう。</p>
<h3 id="rdbへのアクセス">RDBへのアクセス</h3>
<p>多くのアプリケーションはいくつものベンダーやOSSが提供するRDBを利用します。 SQL方言やストアドプロシージャ、専用の監視コンソールなどがロックインに関係してきます。 ロックインを避けるためにどれくらい苦労するべきでしょうか。 ほとんどのプログラミング言語や実行環境には、低コストである程度のデータベース非依存性を保証する汎用的なマッピングフレームワークがあります。 将来的な行使価格を最小化したいなら、SQL関数やストアドプロシージャを諦めましょう。 製品としての性能は低下するかもしれませんし、他の部分にかける時間も長くなるかもしれませんが。</p>
<p><strong>助言</strong>：ロックインを避けるためにあまり苦労しない仕組みを使いましょう。切り替えコスト0を目指してはいけません。</p>
<h3 id="クラウドへの移行">クラウドへの移行</h3>
<p>データベースベンダーを切り替えるより、アプリケーションと一緒にクラウドへ移行することのほうが気になっていると思います。 技術的な考慮事項はいろいろあるけど、ベンダーとのライセンス条項によっては経済的な不利益を被る場合もあるので注意が必要です。 そういうときはOSSのデータベースを使うほうが賢い選択でしょう。</p>
<p><strong>助言</strong>：運用やサポートができるならOSSデータベースを選択しましょう。それはそれで一定のロックインを許容することになりますが。</p>
<h3 id="マルチクラウド">マルチクラウド</h3>
<p>多くのエンタープライズが移植性のあるマルチクラウドデプロイに魅力を感じています。 また、かつてないほど綿密で複雑で費用のかかる計画の存在が、クラウドプロバイダーによるロックインから<strong>表面的に</strong>自由を獲得できているかのように見せかけています。 ただ、そういう計画のほとんどはあなたたちがクラウドへ移行したかった理由（ストレージやデータベースなどをマネージドサービスとして抵抗なく使えるようになりたい）を否定します。</p>
<p><strong>助言</strong>：注意してください。著者による<a href="https://architectelevator.com/cloud/hybrid-multi-cloud/">マルチクラウドの解説</a>も読んでください。</p>
<hr />
<h2 id="アーキテクチャについて思考する速度">アーキテクチャについて思考する速度</h2>
<p>ロックインについてすごい時間をかけて考えてしまう人もいます。 私たちのような考え方を「アカデミック」であるとして敬遠する人もいます。 「アカデミック」を何か悪いことのように言われていることが何回もありますが、ほとんどは学校で習ってきたことばかりです。 それなのに、従来の白か黒で二分するやり方でアーキテクチャをより簡潔に、場合によっては効率的にできるというのでしょうか。</p>
<p>人間の思考は極めて高速に行われています。 この記事で紹介したモデルに全て目を通すだけなら数分もかからないはずですし、それだけで根拠のあるよい決定を下せるようになります。 適当なスケッチをする必要もありません。 高速なアーキテクチャとしての思考に必要なのは集中力なのです。</p>
<p>何週間も先まで定期的に開催することが予定されている、情報を得たところでまともに意思決定できない人たちが参加する長時間のステアリングコミッティミーティングのため、事前にスライドを推敲する労力と比べてみてくさい。</p>
<p>エレベーターに乗る選択をしたアーキテクトには、ミーティングの待ち時間をいろいろなことを考えるために使うことをお勧めします。</p>
</body>
</html>
